#!/bin/bash

#
# This script uses the standard Linux utilities ipset & iptables/ip6tables to create a high performance IP blacklist.
#
# 20180727, jtingiris, v0.0.1 created
# 20181010, jtingiris, v0.0.2 updated
# 20190628, jtingiris, v0.0.3 updated
#
# References
#
# http://ipset.netfilter.org/ipset.man.html#lbAN
# EL 6 ipset doesn't support nomatch https://bugzilla.redhat.com/show_bug.cgi?id=1402201

PATH=/usr/bin:/usr/sbin:/bin:/sbin

# Globals

Verbose_Flag=1 # 0=on, 1=off

Options=()
Options+=(add)
Options+=(auto)
Options+=(check)
Options+=(iptables)
Options+=(remove)
Options+=(restart)
#Options+=(restore) # TODO; support this
Options+=(save)
Options+=(start)
Options+=(status)
Options+=(stop)

Blacklist_Permanent_File=/var/tmp/blacklist.permanent
Blacklist_Permanent_Max=15 # how many IPs on a subnet need to be abusive to qualify for notification

Ipset_Name="labl" # The ipset name(s) prefix.

Ipset_Hashsize=2048 # The initial hash size for Ipset_Name, default is 1024. The hash size must be a power of two, the kernel automatically rounds up non power of two hash sizes to the first correct value.  As more items are added to the ip set, the hash size will grow dynamically by doubling this value when/if needed..

Ipset_Maxelem=131072 # The maximum number of elements/entries in the ipset, default is 65536.  TODO; test max sizes

if [ "$DEBUG" == "" ]; then
    if [ "$Debug" == "" ]; then
        let Debug=0 # 0 disables debug
    else
        let Debug=$Debug # ensure it's an integer
    fi
else
    let Debug=$DEBUG+0
fi

# print formatted output to stdout
function _echo() {
    if [ "$2" == "" ]; then
        local echo_status="OK"
    else
        local echo_status="$2"
    fi

    local -i pad=11
    local -i pad_left=(${pad}-${#echo_status})/2
    if [ ${pad_left} -lt 0 ]; then pad_left=1; fi
    local -i pad_right=(${pad}-${#echo_status})-${pad_left}
    if [ ${pad_right} -lt 0 ]; then pad_right=1; fi

    (>&2 printf "%(%Y-%m-%d %H:%M:%S %Z)T : [%${pad_left}.s%s%${pad_right}.s] : %s\n" "-1" $pad_left "$echo_status" $pad_right "$1")
}

# print formatted output to stderr
function _error() {
    RC=1

    if [ "$2" == "" ]; then
        local error_level="ERROR"
    else
        local error_level="$2"
    fi

    _echo "$1" "$error_level"
}

# exit with a message and non-zero return code
function aborting() {
    printf "\naborting ... $@"
    printf "\n\n"
    if [[ $2 == '^[0-9]+$' ]]; then
        RC=$2
    else
        RC=2
    fi
    exit $RC
}

# output debug message to stderr if global debug is greater than or equal to local debug_level
function debug() {
    if [ $Debug -eq 0 ]; then
        return
    fi

    local debug_message=$1
    local debug_level=$2
    if [[ ! $debug_level =~ ^[0-9]+$ ]]; then
        local -i debug_level=0 # default debug level is 0
    fi

    if [ $Debug -ge $debug_level ]; then
        _echo "$debug_message" "DEBUG(${Debug},${debug_level})"
    fi
}

# output the ip 'family' of an ip address and return true, or output nothing and return false
function ipFamily() {
    local ip=$1

    local ip_family
    if ipv4Valid $ip; then
        ip_family="inet"
    else
        if ipv6Valid $ip; then
            ip_family="inet6"
        fi
    fi

    debug "ip_family = ${ip_family}" 7

    if [ ${#ip_family} -eq 0 ]; then
        return 1
    else
        printf "%s" "$ip_family"
        return 0
    fi
}

# validate an ip address
function ipValid() {

    local ip_address="$1"

    debug "$FUNCNAME ip_address = $ip_address" 34

    if ipcalc -cs "${ip_address}" &> /dev/null; then
        return 0
    else
        return 1
    fi

    return 1
}

# regex for IPv4 validation
function ipv4Valid() {

    if [ $IP4_Enabled -eq 1 ]; then
        return 1
    fi

    local inet=${1}

    if ipcalc -4 -cs "${inet}" &> /dev/null; then
        return 0
    else
        return 1
    fi

    return 1
}

# regex for IPv6 validation
function ipv6Valid() {

    if [ $IP6_Enabled -eq 1 ]; then
        return 1
    fi

    local inet6=${1}

    if ipcalc -4 -cs "${inet6}" &> /dev/null; then
        return 0
    else
        return 1
    fi

    return 1
}

# add an ip address or range to the appropriate ipset
function lablAdd() {

    local ip="$1"
    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi

    if ! ipValid "$ip"; then
        debug "$FUNCNAME ip '$ip' is invalid" 1
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        _echo "$FUNCNAME ip '$ip' is being whitelisted THEN blacklisted (this hasn't been fully tested!)" WARNING
        local whitelist=0
        local blacklist=0
    fi

    local ip_family
    if ! ip_family=$(ipFamily $ip); then
        _echo "$FUNCNAME ip '$ip' ip_family is unsupported" WARNING
        return 1
    fi

    local blacklisted=1
    local whitelisted=1

    # whitelist first
    if [ $whitelist -eq 0 ]; then

        debug "$FUNCNAME ip = $ip ($ip_family) $whitelist whitelist" 14

        # remove it from blacklist
        if lablCheck "$ip" blacklist quiet; then

            debug "$FUNCNAME $ip exists in blacklist" 14

            if lablRemove "$ip" blacklist quiet; then
                local blacklisted=1
                _echo "$ip removed from ${Ipset_Name}_${ip_family} blacklist" OK
            else
                local blacklisted=0
                _echo "$ip was NOT removed from ${Ipset_Name}_${ip_family} blacklist" NOTICE
            fi

            if lablCheck "$ip" blacklist quiet; then
                local blacklisted=0
                _echo "$ip was NOT removed from ${Ipset_Name}_${ip_family} blacklist" WARNING
            fi
        else
            local blacklisted=1
            debug "$FUNCNAME $ip is NOT blacklisted" 14
        fi

        if [ $blacklisted -eq 1 ]; then

            if [ "$Option" == "add" ]; then
                if [ ! -d /etc/labl.d ]; then
                    mkdir -p /etc/labl.d &> /dev/null
                    if [ $? -ne 0 ]; then
                        aborting "[ERROR] mkdir -p /etc/labl.d failed"
                    fi
                fi

                if lablRemove "$ip" blacklist quiet; then
                    _echo "$ip removed from ${Ipset_Name}_${ip_family} blacklist" OK
                fi

                echo "$ip" >> /etc/labl.d/whitelist.add
                sort -uV /etc/labl.d/whitelist.add -o /etc/labl.d/whitelist.add
            fi

            if [ $Ipset_Nomatch -eq 0 ]; then
                # add it to whitelist
                # TODO; revisit this logic; explicit whitelisting or implicit??
                #if lablCheck "$ip" whitelist quiet; then
                #echo "[-] $ip exists in whitelist"
                #else
                # right now it's explicit ...
                ipset -exist add ${Ipset_Name}_${ip_family} $ip nomatch &> /dev/null
                if lablCheck "$ip" whitelist quiet; then
                    _echo "$ip added to ${Ipset_Name}_${ip_family} whitelist" OK
                else
                    _echo "$FUNCNAME $ip was NOT added to ${Ipset_Name}_${ip_family} whitelist" WARNING
                fi
                #fi
                #else
                #_echo "$ip was NOT added to ${Ipset_Name}_${ip_family} whitelist because $Ipset_Version does not support it" WARNING
                # now it's possible to support adding to a whitelist file .. e.g. /etc/labl.d/whitelist.add
            fi
        else
            _echo "unable to whitelist $ip because it's currently blacklisted; try running '$Readlink_0 remove $ip blacklist'" WARNING
        fi

    fi

    # blacklist second
    if [ $blacklist -eq 0 ]; then

        debug "$FUNCNAME ip = $ip ($ip_family) $blacklist blacklist" 14

        # automating this part is subjective; works but needs work

        if lablCheckWhitelists "$ip"; then
            debug "$FUNCNAME $ip exists in a whitelist" 10
        else
            debug "$FUNCNAME [ALLOWING] $ip is NOT whitelisted" 10

            # if it's not in a whitelist, remove it from nomatch set?
            if [ "$Testing" != "" ]; then
                if lablCheck "$ip" whitelist quiet; then

                    debug "$FUNCNAME $ip exists in whitelist" 14
                    local whitelisted=0

                    if lablRemove "$ip" whitelist quiet; then
                        _echo "$ip removed from ${Ipset_Name}_${ip_family} whitelist" OK
                    else
                        _echo "$ip was NOT removed from ${Ipset_Name}_${ip_family} whitelist" NOTICE
                        local whitelisted=0
                    fi

                    if lablCheck "$ip" whitelist; then
                        debug "$FUNCNAME [WARNING] $ip was NOT removed from ${Ipset_Name}_${ip_family} whitelist" 2
                        local whitelisted=0
                    fi
                else
                    debug "$FUNCNAME $ip is NOT whitelisted" 14
                    local whitelisted=0
                fi
            fi
        fi

        # add it to blacklist
        if lablCheck "$ip" blacklist quiet; then
            _echo "$ip already blacklisted" OK
        else
            ipset -exist add ${Ipset_Name}_${ip_family} $ip &> /dev/null
            if lablCheck "$ip" blacklist quiet; then
                _echo "[+++] $ip added to ${Ipset_Name}_${ip_family} blacklist" OK
            fi
        fi

    fi

    unset -v ip_family
}

# automatically add *new* ip address(es) or range(s) to the appropriate ipset
function lablAuto() {

    local blacklist ip_family ipset_family_save
    local -i labl_running=0


    for ip_family in ${IP_Families[@]}; do
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -ne 0 ]; then
            labl_running=1
        fi
    done
    ip_family=""

    # if it's not running properly, then restart, else add *only new* addresses to the ipsets
    if [ $labl_running -eq 1 ]; then
        lablStop
        lablStart
    else
        lablLoadBlacklists blacklist
        lablLoadWhitelists whitelist
    fi

    local ipset_save=/var/tmp/labl.auto.save
    lablSave $ipset_save

    for ip_family in ${IP_Families[@]}; do
        ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
        if [ -f "${ipset_family_save}" ]; then
            cp ${ipset_family_save} ${ipset_family_save}.new
        else
            aborting "[ERROR] can't find ${ipset_family_save}"
        fi
    done
    ip_family=""
    ipset_family_save=""


    for blacklist in ${Blacklists[@]}; do
        debug "$FUNCNAME blacklist = $blacklist" 50

        if ip_family=$(ipFamily $blacklist); then
            ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
            echo add labl_inet $blacklist | sed -e '/\/32/s///g' -e '/\/64/s///g' >> ${ipset_family_save}.new
        else
            _echo "$FUNCNAME ip '$ip' ip_family is unsupported" WARNING
        fi

        ip_family=""
    done
    ipset_family_save=""

    for ip_family in ${IP_Families[@]}; do
        ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
        sort -ruV ${ipset_family_save}.new -o ${ipset_family_save}.new
        local blacklist_add
        for blacklist_add in $(diff ${ipset_family_save} ${ipset_family_save}.new 2> /dev/null | grep ^\> | awk '{print $NF}'); do
            lablAdd $blacklist_add blacklist
        done
        unset -v blacklist_add
    done

    unset -v blacklist ip_family ipset_family_save ipset_save

}


# check if an ip address or range is in an ipset
function lablCheck() {

    local ip blacklist whitelist quiet

    if [ "$1" == "" ]; then
        ip=$IP_Address
    else
        ip=$1
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        blacklist=0
    else
        blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        whitelist=0
    else
        whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            whitelist=0
            blacklist=1
        else
            whitelist=1
            blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        blacklist=0
        whitelist=0
    fi

    if [ "$3" == "quiet" ]; then
        quiet=0
    else
        quiet=1
    fi

    local ip_family
    if ! ip_family=$(ipFamily $ip); then
        _echo "$FUNCNAME ip '$ip' ip_family is unsupported" WARNING
        return 1
    fi

    let blacklisted=1
    let whitelisted=1

    if [ $whitelist -eq 0 ]; then
        debug "$FUNCNAME ip = $ip ($ip_family) whitelist" 5
        # nomatch tests are true for both 'nomatch' rules and absence of specific match rules
        # TODO; fix stdout ... misleading
        ipset test ${Ipset_Name}_${ip_family} $ip &> /dev/null
        if [ $? -ne 0 ]; then
            let whitelisted=0
            if [ $quiet -eq 1 ]; then
                _echo "$ip is whitelisted" CHECK
            fi
        else
            let whitelisted=1
            if [ $quiet -eq 1 ]; then
                _echo "$ip is NOT whitelisted" CHECK
            fi
        fi
        if [ $blacklist -eq 1 ]; then
            return $whitelisted
        fi
    fi

    if [ $blacklist -eq 0 ]; then
        debug "$FUNCNAME ip = $ip ($ip_family) blacklist" 5
        ipset test ${Ipset_Name}_${ip_family} $ip &> /dev/null
        if [ $? -eq 0 ]; then
            let blacklisted=0
            if [ $quiet -eq 1 ]; then
                _echo "$ip is blacklisted" CHECK
            fi
        else
            let blacklisted=1
            if [ $quiet -eq 1 ]; then
                _echo "$ip is NOT blacklisted" CHECK
            fi
        fi
        if [ $whitelist -eq 1 ]; then
            return $blacklisted
        fi
    fi

    return 1
}

# check if an ip address or range is in a whitelist
function lablCheckWhitelists() {

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi
    debug "$FUNCNAME ip = $ip" 14

    lablLoadWhitelists whitelist

    # the following (depends on subnetcalc) to check host ranges; TODO: write (or find) a better alternative

    local ip_range=$(subnetcalc $ip -n -nocolor 2> /dev/null | grep ^Host\ Range)
    debug "$FUNCNAME ip_range = $ip_range" 10

    local -i whitelist_match=1

    local whitelist
    for whitelist in ${Whitelists[@]}; do
        debug "$FUNCNAME whitelist = $whitelist" 10

        # don't check empty whitelist
        if [ ${#whitelist} -eq 0 ]; then
            continue
        fi

        # perfect match
        if [ "$ip" == "$whitelist" ]; then
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist [MATCH, PERFECT]" 22
            local -i whitelist_match=0
            break
        fi

        if [[ "$whitelist" == *"/"* ]]; then
            local whitelist_bits=${whitelist##*/} # ${0##*/}
        else
            local whitelist_bits=""
        fi

        # make sure whitelist_bits is an integer
        if [[ ! $whitelist_bits =~ ^[0-9]+$ ]]; then
            local whitelist_bits=""
        fi

        if [ "$whitelist_bits" == "$whitelist" ]; then
            _error "whitelist_bits == whitelist $whitelist" 3 ERROR # should be dead code, now; leaving to be sure
            continue
        fi

        # if it's not a perfect match, and the whitelist has no host range, then checking other point to point links is pointless
        if [ "$whitelist_bits" == "" ]; then
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist [SKIP, IMPOSSIBLE]" 4
            continue
        fi

        debug "$FUNCNAME ip = $ip, whitelist = $whitelist, whitelist_bits = $whitelist_bits" 12

        # strip the bits off the ip, replace it with the whitelist mask, & compare ranges
        ip_whitelist=${ip%%/*}
        if [ "$whitelist_bits" != "" ]; then
            ip_whitelist+="/$whitelist_bits"
        fi
        local whitelist_range=$(subnetcalc $whitelist -n -nocolor 2> /dev/null | grep ^Host\ Range)
        local ip_whitelist_range=$(subnetcalc $ip_whitelist -n -nocolor 2> /dev/null | grep ^Host\ Range)
        if [ "$whitelist_range" == "" ]; then
            _echo "subnetcalc has an empty host range for ip '$ip' in whitelist '$whitelist'" WARNING
        else
            if [ "$whitelist_range" == "$ip_whitelist_range" ]; then
                debug "$FUNCNAME ip = $ip, whitelist = $whitelist [MATCH, RANGE]" 22
                debug "$FUNCNAME ip = $ip, whitelist = $whitelist ip_whitelist = $ip_whitelist" 14
                debug "$FUNCNAME ip_whitelist_range = $ip_whitelist_range ($ip_whitelist)" 14
                local -i whitelist_match=0
                break
            fi
        fi

        debug "$FUNCNAME ip_range           = $ip_range ($ip)" 14
        debug "$FUNCNAME whitelist_range    = $whitelist_range ($whitelist)" 14

    done
    unset -v whitelist

    # debt; new
    # to be ultra safe, ensuring a larger range isn't allowed if a lower range is whitelisted (that's not a point to point)
    # this is especially IMPORTANT when using older versions of ipset that do *not* support nomatch, e.g. ipset v6.11 (RHEL 6)
    # i.e. 10.11.12.224/27 is whitelisted & 10.11.12.0/24 is blacklisted; 10.11.12.0/24 is allowed with only the above logic

    if [ $whitelist_match -eq 0 ]; then
        debug "$FUNCNAME ip = $ip AND whitelist = $whitelist [MATCH]" 5
        _echo "$ip is whitelisted" NOTICE
        if lablRemove "$ip" blacklist quiet; then
            _echo "$ip removed from ${Ipset_Name}_${ip_family} blacklist" OK
        fi
        return 0
    else
        return 1
    fi

    # TODO better ipv6 whitelist support
}

# output list of standard locations found for a given filename that's readable
function lablFindLists() {

    local find_lists="$1"
    if [ "$find_lists" == "" ]; then
        debug "$FUNCNAME passed no arguments to $FUNCNAME" 1
        return 1
    fi

    debug "$FUNCNAME find_lists = '$find_lists'" 33

    local labl_etc_d=$(dirname $(dirname $Readlink_0) 2> /dev/null)/etc/labl.d/

    local find_dirs=()
    find_dirs+=(/etc/labl.d)
    find_dirs+=($labl_etc_d)

    local found_lists=()
    for find_dir in ${find_dirs[@]}; do
        debug "$FUNCNAME find_dir = $find_dir" 33
        if [ -r "$find_dir" ]; then
            local candidate
            while read candidate; do
                if [ -r $candidate ]; then
                    debug "$FUNCNAME candidate = $candidate (readable)" 30
                    found_lists+=($candidate)
                else
                    debug "$FUNCNAME candidate = $candidate (not readable)" 30
                fi
            done <<< "$(find "${find_dir}" -maxdepth 1 -type f -name "*${find_lists}*" 2> /dev/null | sort -u)" # only files in this directory; do not recurse
            unset -v candidate
        fi
    done

    if [ "${find_lists}" == "blacklist" ]; then
        if [ -r "${Blacklist_Permanent_File}" ]; then
            found_lists+=(${Blacklist_Permanent_File})
        fi
    fi

    if [ "${find_lists}" == "whitelist" ]; then
        if [ -r "${Whitelist_Permanent_File}" ]; then
            found_lists+=(${Whitelist_Permanent_File})
        fi
    fi

    debug "$FUNCNAME found_lists = '$find_lists' = $(echo ${found_lists[@]})" 3

    if [[ "${found_lists[@]}" ]]; then
        echo "${found_lists[@]}"
        return 0
    fi

    return 1
}

# initialize all dependencies, etc.
function lablInit() {

    if [ "$USER" != "root" ]; then
        aborting "must be root" 3
    fi

    # ensure executable dependencies are available
    Dependencies=()
    Dependencies+=(awk)
    Dependencies+=(basename)
    Dependencies+=(cut)
    Dependencies+=(date)
    Dependencies+=(dirname)
    Dependencies+=(find)
    Dependencies+=(ip)
    Dependencies+=(ipcalc)
    Dependencies+=(ipset)
    Dependencies+=(printf)
    Dependencies+=(readlink)
    Dependencies+=(subnetcalc) # subnetcalc
    Dependencies+=(sed)
    Dependencies+=(sort)

    local dependency
    for dependency in ${Dependencies[@]}; do
        which $dependency &> /dev/null
        if [ $? -ne 0 ]; then
            aborting "FAILED which dependency '$dependency'" 3
        fi
    done
    unset -v dependency

    Basename_0=$(basename $0)
    Dirname_0="$(dirname $0)"

    if [ "$Dirname_0" == "." ]; then
        Dirname_0="$PWD"
    fi

    Zero="$Dirname_0/$Basename_0"

    Readlink_0=$(readlink -e $Zero 2> /dev/null)
    if [ "$Readlink_0" == "" ]; then
        aborting "Readlink_0 Zero failed" 3
    fi

    if [ -r "$(dirname ${Readlink_0})/../include/debug-bash/Debug.bash" ]; then
        # not necessariliy required, but nice to have
        source "$(dirname ${Readlink_0})/../include/debug-bash/Debug.bash"
    fi

    debug "$FUNCNAME 0 = $0" 5
    debug "$FUNCNAME Debug = $Debug" 1
    debug "$FUNCNAME Basename_0 = $Basename_0" 1
    debug "$FUNCNAME Dirname_0 = $Dirname_0" 5
    debug "$FUNCNAME Readlink_0 = $Readlink_0" 1
    debug "$FUNCNAME Zero = $Zero" 1

    if [ -r "$(dirname ${Readlink_0})/../include/ip-bash/IP.bash" ]; then
        source "$(dirname ${Readlink_0})/../include/ip-bash/IP.bash"
    else
        aborting "IP.bash failed to source"
    fi

    IP_Families=()

    # cat /proc/sys/net/ipv6/conf/*/disable_ipv6 
    # export vv=$(</proc/sys/net/ipv6/conf/all/disable_ipv6) && echo $vv
    IP6_Enabled=1 # false
    if [[ "$(ip -6 a s)" != "" ]]; then
        Dependencies+=(ip6tables)
        IP6_Enabled=0 # true
        IP_Families+=(inet6)
    fi

    IP4_Enabled=1 # false
    if [[ "$(ip -4 a s)" != "" ]]; then
        Dependencies+=(iptables)
        IP4_Enabled=0 # true
        IP_Families+=(inet)
    fi

    if [ "$IP_Families" == "" ]; then
        aborting "unable to determine what IP famlies are supported on this machine"
    fi

    # re-check dependencies
    local dependency
    for dependency in ${Dependencies[@]}; do
        which $dependency &> /dev/null
        if [ $? -ne 0 ]; then
            aborting "FAILED which dependency '$dependency'" 3
        fi
    done
    unset -v dependency

    if [ "$Basename_0" == "blacklist" ]; then
        Ipset_Mode="blacklist"
    fi

    if [ "$Basename_0" == "whitelist" ]; then
        Ipset_Mode="whitelist"
    fi

    Status_Flag=0

    # evaluate usage flag as sym link or option (arg 1)
    Flag=$(printf "$Basename_0" | awk -F- '{print $2}')
    if [ "$Flag" == "" ]; then
        Flag="$1"
        let Valid_Flag=1
        if [ "$Flag" != "" ]; then

            for Option in ${Options[@]}; do
                if [ "$Flag" == "$Option" ]; then
                    let Valid_Flag=0
                    break;
                fi
            done

            if usageOptionSingle $Option; then
                if [ "$Ipset_Mode" == "" ]; then
                    Ipset_Mode="$2"
                fi
            else
                IP_Address="$2"
                if [ "$Ipset_Mode" == "" ]; then
                    Ipset_Mode="$3"
                fi
            fi
        else
            IP_Address="$1"
            if [ "$Ipset_Mode" == "" ]; then
                Ipset_Mode="$2"
            fi
        fi

        if [ $Valid_Flag -eq 1 ]; then
            if [ "$Flag" == "" ]; then
                debug "$FUNCNAME no flag" 14
                usage
            else
                Flag=""
                usage "invalid flag"
            fi
        fi

        debug "$FUNCNAME Option = $Option (Flag)" 14
    else
        IP_Address="$1"
        if [ "$Ipset_Mode" == "" ]; then
            Ipset_Mode="$2"
        fi
    fi
    debug "$FUNCNAME Flag = $Flag" 14

    if usageOptionSingle $Option; then
        IP_Address=""
    else
        debug "IP_Address = $IP_Address" 1

        if ! ipValid "$IP_Address"; then
            usage "invalid IP address or CIDR range '$IP_Address'"
        fi

    fi

    # no flag or option, basic usage
    if [ "$Flag" == "" ]; then
        usage
    fi

    if [ "$Ipset_Mode" != "whitelist" ]; then
        Ipset_Mode="blacklist"
    fi
    debug "$FUNCNAME Ipset_Mode = $Ipset_Mode" 5

    Ipset_Version=$(ipset -v 2> /dev/null | awk -F, '{print $1}')
    local -i ipset_version_major=$(echo $Ipset_Version | sed '/[a-z]/s///g' |  awk -F. '{print $1}')
    local -i ipset_version_minor=$(echo $Ipset_Version | sed '/[a-z]/s///g' |  awk -F. '{print $2}')
    # TODO; verify exactly which version of ipset starts supporting nomatch & enhance this to allow versions greater than that
    if [ $ipset_version_major -ge 6 ] && [ $ipset_version_minor -ge 19 ]; then
        let Ipset_Nomatch=0
    else
        let Ipset_Nomatch=1
    fi
    debug "Ipset_Version = $Ipset_Version ($Ipset_Nomatch) [$ipset_version_major][$ipset_version_minor]" 1

    if [ "$Ipset_Name" == "" ]; then
        aborting "Ipset_Name is empty" 3
    fi
    debug "$FUNCNAME Ipset_Name = $Ipset_Name" 14

    Timestamp=$(date +%Y%m%d%H%M%S.%N)
    debug "$FUNCNAME Timestamp = $Timestamp" 14

    Tmp_Dir=$(readlink -e "${Dirname_0}/../tmp")

    if [ "$Tmp_Dir" == "" ]; then
        Tmp_Dir="/var/tmp"
    fi

    if [ ! -d "$Tmp_Dir" ]; then
        mkdir -p "$Tmp_Dir"
        if [ $? -ne 0 ]; then
            aborting "failed to make temp directory '$Tmp_Dir'"
        fi
    fi

    if [ ! -d "$Tmp_Dir" ] || [ ! -w "$Tmp_Dir" ]; then
        aborting "'$Tmp_Dir' temporary directory not writable"
    fi

    Tmp_File=${Tmp_Dir}/${Basename_0}.${Timestamp}
    debug "$FUNCNAME Tmp_File = $Tmp_File" 14
}

# load lists of validated ips from file(s)
function lablLoad() {

    if [ "$1" == "" ]; then
        debug "$FUNCNAME passed no arguments to $FUNCNAME" 14
        return 1
    fi

    debug "$FUNCNAME arguments = $(echo $@)" 18

    local load_files=()

    local load_candidates=($@)
    for load_candidate in ${load_candidates[@]}; do
        debug "$FUNCNAME load_candidate = ${load_candidate}" 14
        if [ -r $load_candidate ]; then
            debug "$FUNCNAME load_candidate = $load_candidate (readable)" 33
            load_files+=($load_candidate)
        else
            debug "$FUNCNAME load_candidate = $load_candidate (not readable)" 33
        fi
        unset -v load_candidate
    done
    debug "$FUNCNAME load_files = $(echo ${load_files[@]})" 10

    # pre-load ip(s)

    if [[ "${load_files[@]}" ]]; then

        local load_candidates=()

        local load_file
        for load_file in ${load_files[@]}; do
            if [ -r "${load_file}" ]; then
                local load_script=$(head -1 "${load_file}" 2> /dev/null | grep ^"#!")
                if [ "${load_script}" != "" ]; then
                    debug "$FUNCNAME load_file = $load_file (execute)" 10
                    local load_line
                    while read load_line; do
                        load_candidates+=($load_line)
                    done <<< "$(bash "$load_file" "$Option" | egrep -e '^[0-9]|^[a-f]|^[A-F]' | awk '{print $1}')" # must be one ip per line
                    unset -v load_line
                else
                    debug "$FUNCNAME load_file = $load_file (cat)" 10
                    local load_line
                    while read load_line; do
                        load_candidates+=($load_line)
                    done <<< "$(cat "$load_file" | egrep -e '^[0-9]|^[a-f]|^[A-F]' | awk '{print $1}')" # must be one ip per line
                    unset -v load_line
                fi
            fi
        done
        unset -v load_file

        local load_ips=()

        local load_candidates_uniq=($(printf "%s\n" ${load_candidates[@]} | sort -Vu))
        load_candidates=(${load_candidates_uniq[@]})
        unset -v load_candidates_uniq

        local load_candidate
        for load_candidate in ${load_candidates[@]}; do
            # skip empty lines
            if [ "${load_candidate}" == "" ]; then
                continue
            fi

            # skip comments
            if [ "${load_candidate:0:1}" == "#" ]; then
                continue
            fi

            debug "$FUNCNAME load_candidate = $load_candidate" 30

            local -i valid_load_candidate=1
            if ipValid "$load_candidate"; then
                valid_load_candidate=0
            fi

            if [ $valid_load_candidate -eq 0 ]; then
                debug "$FUNCNAME valid load ip = $load_candidate" 7
                load_ips+=($load_candidate)
            else
                if [ $Status_Flag -eq 1 ] ; then
                    _echo "ignoring IP '$load_candidate'" WARNING
                fi
            fi

        done
        unset -v load_candidate

        if [[ "${load_ips[@]}" ]]; then
            echo "${load_ips[@]}"
            return 0
        fi
    fi

    return 1
}

# load named blacklists into global $Blacklists & $Blacklists_Files
function lablLoadBlacklists() {

    if [ "$1" == "" ]; then
        local -l list_labl=blacklist
    else
        list_labl="$1"
    fi
    debug "$FUNCNAME list_labl = $list_labl" 14

    if [[ ${Blacklists[@]} ]]; then
        if [[ ${Blacklists_Files[@]} ]]; then
            debug "$FUNCNAME blacklists already loaded" 10
            return 0
        fi
    else
        debug "$FUNCNAME blacklists are being loaded" 1
    fi

    Blacklists_Files=($(lablFindLists $list_labl))
    debug "$FUNCNAME Blacklists_Files = $(echo ${Blacklists_Files[@]})" 10

    Blacklists=()
    if [ "$Blacklists_Files" != "" ]; then
        local blacklist
        for blacklist in $(lablLoad "${Blacklists_Files[@]}"); do
            debug "$FUNCNAME blacklist = $blacklist" 13
            Blacklists+=($blacklist)
        done
        unset -v blacklist
    fi

    if [[ ${Blacklists[@]} ]]; then
        if [ $Verbose_Flag -eq 0 ] || [ "$2" == "verbose" ]; then
            if [[ ${Blacklists_Files[@]} ]]; then
                local blacklist_file
                for  blacklist_file in ${Blacklists_Files[@]}; do
                    _echo "blacklist loaded from $blacklist_file" OK
                done
                unset -v blacklist_file
                return 0
            fi
        else
            return 0
        fi
    fi

    return 1
}

# load named whitelists into global $Whitelists & $Whitelists_Files
function lablLoadWhitelists() {

    if [ "$1" == "" ]; then
        local -l list_labl=whitelist
    else
        list_labl="$1"
    fi
    debug "$FUNCNAME list_labl = $list_labl" 14

    if [[ ${Whitelists[@]} ]]; then
        if [[ ${Whitelists_Files[@]} ]]; then
            debug "$FUNCNAME whitelists already loaded" 10
            return 0
        fi
    else
        debug "$FUNCNAME whitelists are being loaded" 1
    fi

    Whitelists_Files=($(lablFindLists $list_labl))
    debug "$FUNCNAME Whitelists_Files = $(echo ${Whitelists_Files[@]})" 10

    Whitelists=()
    if [ "$Whitelists_Files" != "" ]; then
        local whitelist
        for whitelist in $(lablLoad "${Whitelists_Files[@]}"); do
            debug "$FUNCNAME whitelist = $whitelist" 13
            Whitelists+=($whitelist)
        done
        unset -v whitelist
    fi

    if [[ ${Whitelists[@]} ]]; then
        if [ $Verbose_Flag -eq 0 ] || [ "$2" == "verbose" ]; then
            if [[ ${Whitelists_Files[@]} ]]; then
                local whitelist_file
                for whitelist_file in ${Whitelists_Files[@]}; do
                    _echo "whitelist loaded from $whitelist_file" OK
                done
                unset -v whitelist_file
                return 0
            fi
        else
            return 0
        fi
    fi

    return 1
}

# remove an ip address or range from an ipset
function lablRemove() {

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 14
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        local blacklist=0
        local whitelist=0
    fi

    if [ "$3" == "quiet" ]; then
        local quiet=0
    else
        local quiet=1
    fi

    local ip_family
    if ! ip_family=$(ipFamily $ip); then
        _echo "$FUNCNAME ip '$ip' ip_family is unsupported" WARNING
        return 1
    fi

    local blacklist_removed=1
    local whitelist_removed=1

    debug "$FUNCNAME ip = $ip ($ip_family) blacklist=$blacklist whitelist=$whitelist" 10

    if [ $blacklist -eq 0 ]; then
        if lablCheck "$ip" blacklist quiet; then
            ipset del ${Ipset_Name}_${ip_family} $ip
            if lablCheck "$ip" blacklist quiet; then
                _echo "$ip is still in blacklist (manually check the CIDR ranges)" WARNING
            else
                local blacklist_removed=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip removed from ${Ipset_Name}_${ip_family} blacklist" REMOVE
                fi
            fi
        else
            if [ $quiet -eq 1 ]; then
                _echo "$ip is NOT blacklisted" REMOVE
            fi
        fi

        if [ $whitelist -eq 1 ]; then
            return $blacklist_removed
        fi
    fi

    if [ $whitelist -eq 0 ]; then
        if lablCheck "$ip" whitelist quiet; then
            ipset del ${Ipset_Name}_${ip_family} $ip
            if lablCheck "$ip" whitelist quiet; then
                _echo "$ip is still in whitelist (manually check the CIDR ranges)" WARNING
            else
                local whitelist_removed=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip removed from ${Ipset_Name}_${ip_family} whitelist" REMOVE
                fi
            fi
        else
            if [ $quiet -eq 1 ]; then
                _echo "$ip is NOT whitelisted" REMOVE
            fi
        fi

        if [ $blacklist -eq 1 ]; then
            return $whitelist_removed
        fi
    fi

    debug "$FUNCNAME ip = $ip ($ip_family) blacklist & whitelist was NOT removed" 1

    return 1

}

# restore ipsets
function lablRestore() {
    debug "$FUNCNAME Function = $FUNCNAME" 50
}

# save ipsets
function lablSave() {

    if [ "$1" == "" ]; then
        local ipset_save="${Tmp_File}.save"
    else
        local ipset_save="$1"
    fi

    if [ "$ipset_save" == "" ]; then
        debug "$FUNCNAME ipset_save is empty" 14
        return 1
    fi

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
        if [ $Auto_Flag -eq 1 ]; then
            _echo "ipset save ${Ipset_Name}_${ip_family} to $ipset_family_save" SAVE
        fi
        ipset save ${Ipset_Name}_${ip_family} | sort -ruV > "$ipset_family_save"
    done
    unset -v ip_family

}

# check & if needed, create ipsets and iptables/ip6tables rules
function lablStart() {

    local table_exec

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        unset -v table_exec

        if [ "$ip_family" == "inet" ]; then
            if [ $IP4_Enabled -eq 0 ]; then
                table_exec="iptables"
            fi
        else
            if [ $IP6_Enabled -eq 0 ]; then
                table_exec="ip6tables"
            fi
        fi

        if [ "$table_exec" == "" ]; then
            continue
        fi

        debug "$FUNCNAME check $table_exec $ip_family ipset" 10

        # if needed, create ${ip_family} set
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -ne 0 ]; then
            # set doesn't exist, create it
            local ipset_type="hash:net"
            ipset -q create ${Ipset_Name}_${ip_family} $ipset_type hashsize $Ipset_Hashsize maxelem $Ipset_Maxelem family ${ip_family}
            if [ $? -eq 0 ]; then
                _echo "ipset ${Ipset_Name}_${ip_family} created" OK
            else
                aborting "[ERROR] FAILED to ipset create ${Ipset_Name}_${ip_family} $ipset_type hashsize $Ipset_Hashsize maxelem $Ipset_Maxelem family ${ip_family}" 3
            fi
        else
            # set exists, great
            if [ $Verbose_Flag -eq 0 ]; then
                _echo "ipset ${Ipset_Name}_${ip_family} exists" NOTICE
            fi
        fi

        debug "$FUNCNAME check $table_exec $ip_family rule" 10

        # iptables/ip6tables bug ...; sometimes results aren't produced on the first try ... :/
        local table_count=0

        local -i table_try=3
        while [ $table_try -gt 0 ]; do
            if [ $table_count -eq 0 ]; then
                local table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            else
                break
            fi
            ((--table_try))
        done
        debug "$FUNCNAME $table_exec $ip_family table_try = $table_try" 10

        if [ $table_count -eq 0 ]; then
            # insert [first rule]
            $table_exec -I INPUT 1 -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP
            if [ $? -eq 0 ]; then
                _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} started" OK
            else
                aborting "[ERROR] FAILED to $table_exec -I INPUT 1 -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP" 3
            fi
        else
            if [ $table_count -eq 1 ]; then
                if [ $Verbose_Flag -eq 0 ]; then
                    _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} running" OK
                fi
            else
                aborting "[ERROR] $table_exec --match-set ${Ipset_Name}_${ip_family} is loaded $table_count times, try restarting" 3
            fi
        fi

    done
    unset -v ip_family

    if [ $Verbose_Flag -eq 0 ]; then
        printf "\n"
    fi

    if [ $Iptables_Flag -eq 0 ] && [ "$1" == "iptables" ]; then
        _echo "$Basename_0 start successful" "OK"
        return
    fi

    lablLoadBlacklists blacklist
    lablLoadWhitelists whitelist

    if [ $Verbose_Flag -eq 0 ]; then
        printf "\n"
    fi

    if usageOptionSingle $Option; then

        # whitelist, then blacklist

        local whitelist
        for whitelist in ${Whitelists[@]}; do
            debug "$FUNCNAME whitelist = $whitelist" 10
            lablAdd $whitelist whitelist
        done
        unset -v whitelist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        local blacklist
        for blacklist in ${Blacklists[@]}; do
            debug "$FUNCNAME blacklist = $blacklist" 10
            lablAdd $blacklist blacklist
        done
        unset -v blacklist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        # whitelisting a second time allows whitelists to override blacklists

        local whitelist
        for whitelist in ${Whitelists[@]}; do
            debug "$FUNCNAME whitelist = $whitelist" 10
            lablAdd $whitelist whitelist
        done
        unset whitelist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        _echo "$Basename_0 start successful" "OK"
        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

    fi
}

# list contents of all ipsets & iptables rules
function lablStatus() {

    Status_Flag=0

    local -i labl_running=1

    local ipset_match=""
    if [ $Ipset_Nomatch -eq 0 ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local ipset_match="nomatch"
        fi
    fi

    local labl_inet_count=0
    local labl_inet_blacklist_count=0
    local labl_inet_whitelist_count=0

    local labl_inet6_count=0
    local labl_inet6_blacklist_count=0
    local labl_inet6_whitelist_count=0

    local ip_family_count=0

    local table_exec

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        unset -v table_exec

        if [ "$ip_family" == "inet" ]; then
            if [ $IP4_Enabled -eq 0 ]; then
                table_exec="iptables"
            fi
        else
            if [ $IP6_Enabled -eq 0 ]; then
                table_exec="ip6tables"
            fi
        fi

        if [ ${#table_exec} -eq 0 ]; then
            continue
        fi

        debug "$FUNCNAME check $table_exec $ip_family ipset" 10

        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -eq 0 ]; then
            labl_running=0

            if [ $ip_family_count -eq 0 ]; then
                printf -- "----------------------------------------------------------------\n"
                let ip_family_count=$ip_family_count+1
            fi

            ipset -t list ${Ipset_Name}_${ip_family} 2> /dev/null > /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
            if [ -r /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp} ]; then
                printf "\n"
                cat /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
            fi

            debug "$FUNCNAME check $table_exec $ip_family rule" 10

            # iptables/ip6tables bug ...; sometimes they doesn't produce results on the first try ...
            local table_count=0

            local -i table_try=3
            while [ $table_try -gt 0 ]; do
                if [ $table_count -eq 0 ]; then
                    table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
                else
                    break
                fi
                ((--table_try))
            done

            debug "$FUNCNAME table_try = $table_try" 10

            printf "\n"

            if [ $table_count -eq 0 ]; then
                printf "[-] $table_exec --match-set ${Ipset_Name}_${ip_family} was NOT loaded\n"
            else
                if [ $table_count -eq 1 ]; then
                    printf "[+] $table_exec --match-set ${Ipset_Name}_${ip_family} loaded\n\n"
                else
                    printf "[WARNING] $table_exec --match-set ${Ipset_Name}_${ip_family} loaded $table_count times\n\n"
                fi

                if [ "$1" != "permanent" ] && [ "$1" != "verbose" ]; then
                    continue
                fi

                lablLoadBlacklists blacklist
                lablLoadWhitelists whitelist

                #
                # blacklist status
                #

                local -i labl_blacklist_count=$(ipset save ${Ipset_Name}_${ip_family} | grep ^add | grep -v nomatch$ | wc -l)
                if [ $labl_blacklist_count -eq 0 ]; then
                    local -i labl_blacklists_count=1
                else
                    local -i labl_blacklists_count=0
                fi

                if [[ ${Blacklists_Files[@]} ]]; then
                    printf "[+]\n"
                    printf "[+] Blacklists ($ip_family)\n"
                    printf "[+]\n\n"
                    local blacklists_file
                    for blacklists_file in ${Blacklists_Files[@]}; do
                        let blacklists_file_count=0
                        printf "$blacklists_file\n\n"
                        Status_Flag=1
                        if [ "$ip_family" == "inet6" ]; then
                            local blacklist_inet
                            for blacklist_inet in $(printf "%s\n" $(lablLoad $blacklists_file lablStatus) | egrep -e '^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*'); do
                                printf "$blacklist_inet\n"
                                let blacklists_file_count=$blacklists_file_count+1
                                if [ $labl_blacklists_count -eq 1 ]; then
                                    let labl_blacklist_count=$labl_blacklist_count+1
                                fi
                            done
                            unset -v blacklist_inet
                        else
                            local blacklist_inet
                            for blacklist_inet in $(printf "%s\n" $(lablLoad $blacklists_file lablStatus) | egrep -e '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'); do
                                printf "$blacklist_inet\n"
                                let blacklists_file_count=$blacklists_file_count+1
                                if [ $labl_blacklists_count -eq 1 ]; then
                                    let labl_blacklist_count=$labl_blacklist_count+1
                                fi
                            done
                            unset -v blacklist_inet
                        fi
                        if [ $blacklists_file_count -eq 0 ]; then
                            printf "!! empty $ip_family blacklist !!\n"
                        fi
                        Status_Flag=0
                        printf "\n"
                    done
                    unset -v blacklists_file
                    printf "\n"
                fi

                if [ "${ip_family}" == "inet" ]; then
                    let labl_inet_count=$labl_inet_count+$labl_blacklist_count
                    let labl_inet_blacklist_count=$labl_inet_blacklist_count+$labl_blacklist_count
                fi

                if [ "${ip_family}" == "inet6" ]; then
                    let labl_inet6_count=$labl_inet6_count+$labl_blacklist_count
                    let labl_inet6_blacklist_count=$labl_inet6_blacklist_count+$labl_blacklist_count
                fi

                #
                # whitelist status
                #

                local -i labl_whitelist_count=$(ipset save ${Ipset_Name}_${ip_family} | grep ^add | grep nomatch$ | wc -l)
                if [ $labl_whitelist_count -eq 0 ]; then
                    local -i labl_whitelists_count=1
                else
                    local -i labl_whitelists_count=0
                fi

                if [[ ${Whitelists_Files[@]} ]]; then
                    printf "[+]\n"
                    printf "[+] Whitelists ($ip_family)\n"
                    printf "[+]\n\n"
                    local whitelists_file
                    for whitelists_file in ${Whitelists_Files[@]}; do
                        let whitelists_file_count=0
                        printf "$whitelists_file\n\n"
                        Status_Flag=1
                        if [ "$ip_family" == "inet6" ]; then
                            local whitelist_inet
                            for whitelist_inet in $(printf "%s\n" $(lablLoad $whitelists_file lablStatus) | egrep -e '^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*'); do
                                printf "$whitelist_inet\n"
                                let whitelists_file_count=$whitelists_file_count+1
                                if [ $labl_whitelists_count -eq 1 ]; then
                                    let labl_whitelist_count=$labl_whitelist_count+1
                                fi
                            done
                            unset -v whitelist_inet
                        else
                            local whitelist_inet
                            for whitelist_inet in $(printf "%s\n" $(lablLoad $whitelists_file lablStatus) | egrep -e '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'); do
                                printf "$whitelist_inet\n"
                                let whitelists_file_count=$whitelists_file_count+1
                                if [ $labl_whitelists_count -eq 1 ]; then
                                    let labl_whitelist_count=$labl_whitelist_count+1
                                fi
                            done
                            unset -v whitelist_inet
                        fi
                        if [ $whitelists_file_count -eq 0 ]; then
                            printf "!! empty $ip_family whitelist !!\n"
                        fi
                        Status_Flag=0
                        printf "\n"
                    done
                    unset -v whitelists_file
                    printf "\n"
                fi

                if [ "${ip_family}" == "inet" ]; then
                    let labl_inet_count=$labl_inet_count+$labl_whitelist_count
                    let labl_inet_whitelist_count=$labl_inet_whitelist_count+$labl_whitelist_count
                fi

                if [ "${ip_family}" == "inet6" ]; then
                    let labl_inet6_count=$labl_inet6_count+$labl_whitelist_count
                    let labl_inet6_whitelist_count=$labl_inet6_whitelist_count+$labl_whitelist_count
                fi

                # ip_family summary

                printf "[+]\n"
                printf "[+] Summary ($ip_family)\n"
                printf "[+]\n\n"
                printf "$labl_blacklist_count blacklisted & $labl_whitelist_count whitelisted ${ip_family} addresses and/or ranges\n"
            fi
            printf "\n"
        fi

        if [ $labl_running -eq 0 ]; then
            printf -- "----------------------------------------------------------------\n\n"
        fi
    done
    unset -v ip_family

    if [ $Iptables_Flag -ne 0 ]; then
        if [ $labl_running -eq 0 ]; then
            if [ $labl_inet_count -ne 0 ] && [ $labl_inet6_count -ne 0 ]; then
                if [ $IP6_Enabled -eq 0 ]; then
                    printf "$labl_inet6_blacklist_count blacklisted and $labl_inet6_whitelist_count whitelisted v6 IP addresses\n"
                fi

                if [ $IP4_Enabled -eq 0 ]; then
                    printf "$labl_inet_blacklist_count blacklisted and $labl_inet_whitelist_count whitelisted v4 IP addresses\n"
                fi

                printf "\nlabl is running"

                if [ $IP4_Enabled -eq 0 ] || [ $IP6_Enabled -eq 0 ]; then
                    printf ", "

                    if [ $IP4_Enabled -eq 0 ]; then
                        printf "$labl_inet_count v4"
                    fi

                    if [ $IP4_Enabled -eq 0 ] && [ $IP6_Enabled -eq 0 ]; then
                        printf " and "
                    fi

                    if [ $IP6_Enabled -eq 0 ]; then
                        printf "$labl_inet6_count v6"
                    fi

                    printf " addresses loaded\n"
                else
                    printf "\n"
                fi
            fi

            # TODO debt; this part works but needs work.
            if [ $Permanent_Flag -eq 0 ]; then

                printf "[+]\n"
                printf "[+] Permanent (check); $Blacklist_Permanent_File\n"
                printf "[+]\n\n"

                if [ ! -d $(dirname "$Blacklist_Permanent_File") ]; then
                    mkdir -p "$(dirname "$Blacklist_Permanent_File")" &> /dev/null
                    if [ $? -ne 0 ]; then
                        aborting "[ERROR] mkdir -p $(dirname "$Blacklist_Permanent_File") failed"
                    fi
                fi

                printf "\n"

                local permanent_qualifiers=0

                local ip_family
                for ip_family in ${IP_Families[@]}; do
                    while read blacklist_ip; do
                        if ipv4Valid $blacklist_ip; then
                            local blacklist_qualifier=$(echo "$blacklist_ip" | awk -F\. '{print $1"."$2"."$3}')
                            local blacklist_qualifier_count=$(ipset save ${Ipset_Name}_${ip_family} | grep -v nomatch$ | awk '{print $NF}' | grep ^${blacklist_qualifier}\. | wc -l)
                            if [ $blacklist_qualifier_count -gt $Blacklist_Permanent_Max ]; then
                                if ! grep ^${blacklist_qualifier}.0/24 "$Blacklist_Permanent_File" &> /dev/null; then
                                    _echo "# blacklisted ip = $blacklist_ip, qualifier $blacklist_qualifier currently has $blacklist_qualifier_count blacklisted which is >= $Blacklist_Permanent_Max" WARNING
                                    echo "${blacklist_qualifier}.0/24" >> "${Blacklist_Permanent_File}"
                                    if [ $? -eq 0 ]; then
                                        _echo "# ${blacklist_qualifier}.0/24 added to $Blacklist_Permanent_File" NOTICE
                                    else
                                        _error "# ${blacklist_qualifier}.0/24 failed to add to $Blacklist_Permanent_File" ERROR
                                    fi
                                    let permanent_qualifiers=$permanent_qualifiers+1
                                fi
                            fi
                        fi
                    done <<<  "$(ipset save ${Ipset_Name}_${ip_family} | grep -v nomatch$ | grep ^add | awk '{print $NF}' | grep -v \/ | sort -uV)"
                done
                unset -v ip_family

                if [ ${permanent_qualifiers} -le 0 ]; then
                    _echo "permanent check completed; no qualifiers found" OK
                else
                    if [ -w "${Blacklist_Permanent_File}" ]; then
                        sort -uV "${Blacklist_Permanent_File}" -o "${Blacklist_Permanent_File}"
                    fi
                fi

            fi
        else
            printf "\nlabl is NOT running\n\n"
        fi
    fi

    if [ $Permanent_Flag -ne 0 ]; then
        ${table_exec} -L INPUT -n
    fi

    # clean up
    local ip_family
    for ip_family in ${IP_Families[@]}; do
        if [ -r /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp} ]; then
            rm -f /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
        fi
    done
    unset -v ip_family

    exit 0
}

# remove all ip family rules & ipsets
function lablStop() {

    local rc=0

    local table_exec

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        unset -v table_exec

        if [ "$ip_family" == "inet" ]; then
            if [ "$IP4_Enabled" -eq 0 ]; then
                table_exec="iptables"
            fi
        else
            if [ "$IP6_Enabled" -eq 0 ]; then
                table_exec="ip6tables"
            fi
        fi

        if [ "$table_exec" == "" ]; then
            continue
        fi

        debug "$FUNCNAME check $table_exec $ip_family rule" 10

        # iptables/ip6tables bug ...; sometimes they doesn't produce results on the first try ...

        local table_count=0
        let local table_exec_rc=0
        let local table_stopped=0
        let local table_try=0
        let local table_try_max=10

        for ((table_try=0; table_try<$table_try_max; table_try++)); do
            local table_count=$($table_exec -n -L INPUT 2> /dev/null | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            if [ $table_count -ne 0 ]; then
                break
            fi
        done
        debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try" 3

        if [ $table_count -gt 0 ]; then
            # match-set.labl_ is loaded into iptables

            for ((table_try=0; table_try<$table_try_max; table_try++)); do
                $table_exec -D INPUT -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP &> /dev/null
                table_exec_rc=$?
                if [ $table_exec_rc -eq 0 ]; then
                    let table_stopped=$table_stopped+1
                    break
                fi
                debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try, table_exec_rc=$table_exec_rc" 4
            done
            debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try, table_try_max = $table_try_max" 4

        else
            debug "$FUNCNAME $table_exec --match-set ${Ipset_Name}_${ip_family} stopped" 10
        fi

        # second time, check to be sure it's stopped
        for ((table_try=0; table_try<$table_try_max; table_try++)); do
            local table_count=$($table_exec -n -L INPUT 2> /dev/null | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            if [ $table_count -ne 0 ]; then
                break
            fi
        done
        debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try" 3


        if [ $table_count -gt 0 ]; then
            _error "FAILED to remove $table_exec --match-set ${Ipset_Name}_${ip_family}" ERROR
            rc=4
        else
            if [ $table_stopped -gt 0 ]; then
                _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} stopped" OK
            else
                _echo "[-] $table_exec --match-set ${Ipset_Name}_${ip_family} was NOT loaded" NOTICE
            fi
        fi

        # check ${ip_family} set
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -eq 0 ]; then
            ipset -q destroy ${Ipset_Name}_${ip_family}
            if [ $? -eq 0 ]; then
                _echo "destoyed ipset ${Ipset_Name}_${ip_family}" OK
            else
                _error "FAILED to destoy ipset ${Ipset_Name}_${ip_family}" ERROR
                rc=4
            fi
        else
            _echo "ipset ${Ipset_Name}_${ip_family} was NOT loaded" NOTICE
        fi

    done
    unset -v ip_family

    if [ -f "${Tmp_File}" ]; then
        rm -f "${Tmp_File}" &> /dev/null
    fi

    if [ $rc -ne 0 ]; then
        _error "FAILED to $Basename_0 $Option" ERROR
        exit $rc
    else
        if usageOptionSingle $Option; then
            _echo "$Basename_0 stop successful" "OK"
        fi
    fi

}

# cli usage
function usage() {

    local ip_address="<ip|ip/bits>"

    local usage_header="usage: $Basename_0"
    local usage_footer=" [blacklist|whitelist] # optional, blacklist is default"
    if [ "$Flag" == "" ]; then
        local usage_message="$usage_header <"
        for Option in ${Options[@]}; do
            # these options do NOT require an ip|ip/cdr
            if usageOptionSingle $Option; then
                continue
            fi
            usage_message+="$Option|"
        done
        unset -v Option
        usage_message=$(printf "$usage_message" | sed -e '/|$/s///g')
        usage_message+="> $ip_address"
        if [ "$Ipset_Mode" == "" ]; then
            local usage_message+=$usage_footer
        fi
        usage_message+="\n-or-\n$usage_header <auto|iptables|restart|start|status|stop>"
    else
        if [ "$Option" == "$Flag" ]; then
            local usage_message="$usage_header $Option $ip_address"
        else
            local usage_message="$usage_header $ip_address"
        fi
        if [ "$Ipset_Mode" == "" ]; then
            local usage_message+=$usage_footer
        fi
    fi
    if [ "$1" != "" ]; then
        usage_message+="\n\nNOTE: $@"
    fi
    printf "\n$usage_message\n\n"

    exit 1
}

# cli usage options that don't require any extra arguments
function usageOptionSingle() {

    local option="$1"

    if [ "$option" == "auto" ] || [ "$option" == "restart" ] || [ "$option" == "save" ] || [ "$option" == "start" ] || [ "$option" == "iptables" ] || [ "$option" == "status" ] || [ "$option" == "stop" ]; then
        return 0
    fi

    return 1
}

# Main

lablInit $@

# supported options without other arguments are restart, start, status, stop

# flags: 0=true, 1=false
Add_Flag=1
Check_Flag=1
Iptables_Flag=1
Permanent_Flag=1
Remove_Flag=1
Restart_Flag=1
Save_Flag=1
Start_Flag=1
Status_Flag=1
Stop_Flag=1

# status is a special option, exit
if [ "$Option" == "status" ]; then
    Status_Flag=0
    if [ "$2" == "permanent" ]; then
        Permanent_Flag=0 # 0=true, 1=false
        lablStatus
    else
        lablStatus "$2"
    fi
    exit
fi

# iptables is a special option, exit
if [ "$Option" == "iptables" ]; then
    Start_Flag=0 # 0=true, 1=false
    Status_Flag=0 # 0=true, 1=false
    Iptables_Flag=0 # 0=true, 1=false
    lablStart iptables
    lablStatus iptables
    exit
fi

# start is a special option, exit
if [ "$Option" == "start" ]; then
    Start_Flag=0 # 0=true, 1=false
    lablStart
    exit
fi

# stop is a special option, exit
if [ "$Option" == "stop" ]; then
    Stop_Flag=0 # 0=true, 1=false
    lablStop
    exit
fi

# restart is a special option, exit
if [ "$Option" == "restart" ]; then
    Restart_Flag=0 # 0=true, 1=false
    lablStop
    lablStart
    exit
fi

if [ "$Option" == "save" ]; then
    Save_Flag=0 # 0=true, 1=false
    lablSave "$IP_Address"
    exit
fi

# auto is super special, it requires lablStart but no IP validation
Auto_Flag=1 # 0=true, 1=false
if [ "$Option" == "auto" ]; then
    Auto_Flag=0 # 0=true, 1=false
    lablAuto
else
    # all other supported options require a valid(ated) IP Address, ipset(s), and iptables/ip6tables rules
    lablStart
fi

if [ "$Option" == "add" ]; then
    Add_Flag=0 # 0=true, 1=false
    lablAdd "$IP_Address" "$Ipset_Mode"
    exit
fi

if [ "$Option" == "check" ]; then
    Check_Flag=0 # 0=true, 1=false
    lablCheck "$IP_Address"
    exit
fi

if [ "$Option" == "remove" ]; then
    Remove_Flag=0 # 0=true, 1=false
    lablRemove "$IP_Address"
    exit
fi

#
# Copyright (C) 2018, Joseph Tingiris
#
