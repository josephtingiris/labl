#!/bin/bash

#
# This script uses the standard Linux utilities ipset & iptables/ip6tables to create a high performance IP blacklist.
#
# 20180727, jtingiris, created
#
# References
#
# http://ipset.netfilter.org/ipset.man.html#lbAN
# EL 6 ipset doesn't support nomatch https://bugzilla.redhat.com/show_bug.cgi?id=1402201

PATH=/usr/bin:/usr/sbin:/bin:/sbin

# Globals

Verbose_Flag=1 # 0=on, 1=off

Options=()
Options+=(add)
Options+=(auto)
Options+=(check)
Options+=(remove)
Options+=(restart)
#Options+=(restore) # TODO; support this
Options+=(save)
Options+=(start)
Options+=(status)
Options+=(stop)

IP_Families=(inet6 inet)

Ipset_Name="labl" # The ipset name(s) prefix.

Ipset_Hashsize=2048 # The initial hash size for Ipset_Name, default is 1024. The hash size must be a power of two, the kernel automatically rounds up non power of two hash sizes to the first correct value.  As more items are added to the ip set, the hash size will grow dynamically by doubling this value when/if needed..

Ipset_Maxelem=131072 # The maximum number of elements/entries in the ipset, default is 65536.  TODO; test max sizes

if [ "$DEBUG" == "" ]; then
    if [ "$Debug" == "" ]; then
        let Debug=0 # 0 disables debug
    else
        let Debug=$Debug # ensure it's an integer
    fi
else
    let Debug=$DEBUG+0
fi

if [ "$USER" != "root" ]; then
    aborting "must be root" 3
fi

Tmp_Dir=/opt/labl/tmp

# print formatted output to stdout
function _echo() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$2" == "" ]; then
        local echo_status="OK"
    else
        local echo_status="$2"
    fi

    local pad=11
    let local pad_left=(${pad}-${#echo_status})/2
    if [ ${pad_left} -lt 0 ]; then pad_left=1; fi
    let local pad_right=(${pad}-${#echo_status})-${pad_left}
    if [ ${pad_right} -lt 0 ]; then pad_right=1; fi

    (>&2 printf "$(date) : [%${pad_left}.s%s%${pad_right}.s] : %s\n" $pad_left "$echo_status" $pad_right "$1")

}

# print formatted output to stderr
function _error() {
    RC=1

    if [ "$2" == "" ]; then
        local error_level="ERROR"
    else
        local error_level="$2"
    fi

    _echo "$1" "$error_level"
}

# exit with a message and non-zero return code
function aborting() {
    printf "\naborting ... $@"
    printf "\n\n"
    if [[ $2 == '^[0-9]+$' ]]; then
        RC=$2
    else
        RC=2
    fi
    exit $RC
}

    # print debug output to stderr if global debug is greater than or equal to local debug_level
    function debug() {
        if [ $Debug -eq 0 ]; then
            return
        fi

        local debug_message=$1
        local debug_level=$(echo "$2" |  sed "s/[^0-9]//g")

        if [ "$debug_level" == "" ]; then
            local -i debug_level=0 # default debug level is 0
        fi

        if [ $Debug -ge $debug_level ]; then
            _echo "$debug_message" "DEBUG(${Debug},${debug_level})"
        fi
    }

# regex to validate hostname
function hostnameValid() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local hostname=${1}
    [[ $hostname =~ ^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9]).)*([A-Za-z]|[A-Za-z][A-Za-z0-9-]*[A-Za-z0-9])$ ]] || return 1
    return 0
}

# validate 'IP_Address' & set global IP_Address_Family if it passes
function ipValid() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local ip_address="$1"

    debug "$FUNCNAME ip_address = $ip_address" 34

    # the rest of the options require an ip|ip/cidr, so that must be validated ...
    if [ "$ip_address" == "" ]; then
        _echo "empty ip_address passed to $FUNCNAME" WARNING
        return 1
    else

        # hostnames are NOT supported
        if hostnameValid "$ip_address"; then
            debug "$FUNCNAME Valid Hostname" 34
            IP_Address_Family="hostname"
        else
            debug "$FUNCNAME Invalid Hostname" 33
        fi

        if [ "$IP_Address_Family" == "" ]; then
            if ipv4Valid "$ip_address"; then
                debug "$FUNCNAME Valid IPv4 IP Address" 34
                IP_Address_Family="inet"
            else
                debug "$FUNCNAME Invalid IPv4 IP Address" 33
            fi
        fi

        if [ "$IP_Address_Family" == "" ]; then
            if ipv4ValidCidr "$ip_address"; then
                debug "$FUNCNAME Valid IPv4 CIDR Range" 34
                IP_Address_Family="inet"
            else
                debug "$FUNCNAME Invalid IPv4 CIDR Range" 33
            fi
        fi

        if [ "$IP_Address_Family" == "" ]; then
            if ipv6Valid "$ip_address"; then
                debug "$FUNCNAME Valid IPv6 IP Address" 34
                IP_Address_Family="inet6"
            else
                debug "$FUNCNAME Invalid IPv6 IP Address" 33
            fi
        fi

        if [ "$IP_Address_Family" == "" ]; then
            if ipv6ValidCidr "$ip_address"; then
                debug "$FUNCNAME Valid IPv6 CIDR Range" 34
                IP_Address_Family="inet6"
            else
                debug "$FUNCNAME Invalid IPv6 CIDR Range" 33
            fi
        fi

        if [ "$IP_Address_Family" == "hostname" ] || [ "$IP_Address_Family" == "" ]; then
            debug "$FUNCNAME invalid IP_Address_Family $IP_Address_Family" 33
            if [ "$IP_Address_Family" == "" ]; then
                if [ $Status_Flag -eq 1 ]; then
                    _echo "empty IP_Address_Family in $FUNCNAME" WARNING
                fi
            fi
            return 1
        else
            debug "$FUNCNAME IP_Address_Family = $IP_Address_Family" 33
        fi
    fi

    debug "$FUNCNAME ip_address = $ip_address" 32

    return 0

}

# regex for IPv4 validation
function ipv4Valid() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local inet=${1}

    if [[ $inet =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        if [[ $inet =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ ]]; then
            return 0
        fi
    fi

    return 1

}

# regex for IPv4 CIDR validation
function ipv4ValidCidr() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local inet_range=${1}

    if [[ $inet_range =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$ ]]; then
        return 0
    fi

    return 1
}

# regex for IPv6 validation
function ipv6Valid() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local inet6=${1}

    if [[ $inet6 =~ ^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s* ]]; then
        return 0
    fi

    return 1
}

# regex for IPv6 CIDR validation
function ipv6ValidCidr() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local inet6_range=${1}

    if [[ $inet6_range =~ ^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\/(d|dd|1[0-1]d|12[0-8]))$ ]]; then
        return 0
    fi

    return 1
}

# add an ip address or range to the appropriate ipset
function lablAdd() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local ip="$1"
    if ! ipValid "$ip"; then
        debug "$FUNCNAME ip $ip is invalid" 1
        return 1
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        _echo "$FUNCNAME ip $ip is being whitelisted THEN blacklisted (this hasn't been fully tested!)" WARNING
        local whitelist=0
        local blacklist=0
    fi

    if ipv4Valid "$ip"; then
        local ip_families=("inet")
    else
        if ipv4ValidCidr "$ip"; then
            local ip_families=("inet")
        else
            if ipv6Valid "$ip"; then
                local ip_families=("inet6")
            else
                if ipv6ValidCidr "$ip"; then
                    local ip_families=("inet6")
                else
                    local ip_families=(${IP_Families[@]})
                fi
            fi
        fi
    fi
    debug "ip_families = ${ip_families[@]}" 7

    local ip_family
    for ip_family in ${ip_families[@]}; do

        local blacklisted=1
        local whitelisted=1

        # whitelist first
        if [ $whitelist -eq 0 ]; then

            debug "$FUNCNAME ip = $ip ($ip_family) $whitelist whitelist" 14

            # remove it from blacklist
            if lablCheck "$ip" blacklist quiet; then

                debug "$FUNCNAME $ip exists in blacklist" 14

                if lablRemove "$ip" blacklist quiet; then
                    local blacklisted=1
                    _echo "$ip removed from blacklist" OK
                else
                    local blacklisted=0
                    _echo "$ip NOT removed from blacklist" NOTICE
                fi

                if lablCheck "$ip" blacklist quiet; then
                    local blacklisted=0
                    _echo "$ip NOT removed from blacklist" WARNING
                fi
            else
                local blacklisted=1
                debug "$FUNCNAME $ip is NOT in blacklist" 14
            fi

            if [ $blacklisted -eq 1 ]; then
                if [ $Ipset_Nomatch -eq 0 ]; then
                    # add it to whitelist
                    # TODO; revisit this logic; explicit whitelisting or implicit??
                    #if lablCheck "$ip" whitelist quiet; then
                    #echo "[-] $ip exists in whitelist"
                    #else
                    # right now it's explicit ...
                    ipset -exist add ${Ipset_Name}_${ip_family} $ip nomatch &> /dev/null
                    if lablCheck "$ip" whitelist quiet; then
                        _echo "$ip added to whitelist" OK
                    else
                        _echo "$FUNCNAME $ip NOT added to whitelist" WARNING
                    fi
                    #fi
                else
                    _echo "$ip NOT added to whitelist because $Ipset_Version does not support it" WARNING
                    # now it's possible to support adding to a whitelist file .. e.g. /etc/labl.d/whitelist.add
                fi
            else
                _echo "unable to whitelist $ip because it's currently blacklisted; try running '$Readlink_0 remove $ip blacklist'" WARNING
            fi

        fi

        # blacklist second
        if [ $blacklist -eq 0 ]; then

            debug "$FUNCNAME ip = $ip ($ip_family) $blacklist blacklist" 14

            # automating this part is subjective; works but needs work

            if lablCheckWhitelists "$ip"; then
                debug "$FUNCNAME $ip exists in a whitelist" 10
                _echo "$ip NOT blacklisted" NOTICE
                continue
            else
                debug "$FUNCNAME [ALLOWING] $ip is NOT in a whitelist" 10

                # if it's not in a whitelist, remove it from nomatch set?
                if [ "$Testing" != "" ]; then
                    if lablCheck "$ip" whitelist quiet; then

                        debug "$FUNCNAME $ip exists in whitelist" 14
                        local whitelisted=0

                        if lablRemove "$ip" whitelist quiet; then
                            _echo "$ip removed from whitelist" OK
                        else
                            _echo "$ip NOT removed from whitelist" NOTICE
                            local whitelisted=0
                        fi

                        if lablCheck "$ip" whitelist; then
                            debug "$FUNCNAME [WARNING] $ip NOT removed from whitelist" 2
                            local whitelisted=0
                        fi
                    else
                        debug "$FUNCNAME $ip is NOT in whitelist" 14
                        local whitelisted=0
                    fi
                fi
            fi

            # add it to blacklist
            if lablCheck "$ip" blacklist quiet; then
                _echo "$ip is already blacklisted" OK
            else
                ipset -exist add ${Ipset_Name}_${ip_family} $ip &> /dev/null
                if lablCheck "$ip" blacklist quiet; then
                    _echo "[+++] $ip added to blacklist" OK
                fi
            fi

        fi
    done
    unset ip_family

}

# automatically add *new* ip address(es) or range(s) to the appropriate ipset
function lablAuto() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    # check if labl is already running (properly)
    let local labl_running=0
    local ip_families=(${IP_Families[@]})
    for ip_family in ${ip_families[@]}; do
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -ne 0 ]; then
            let local labl_running=1
        fi
    done

    # if it's not running properly, then restart, else add *only new* addresses to the ipsets
    if [ $labl_running -eq 1 ]; then
        lablStop
        lablStart
    else
        local ipset_save=/var/tmp/labl.auto.save
        lablSave $ipset_save

        local ip_families
        for ip_families in ${IP_Families[@]}; do
            local ipset_families_save="${ipset_save}.${Ipset_Name}_${ip_families}"
            if [ -f "${ipset_families_save}" ]; then
                cp ${ipset_families_save} ${ipset_families_save}.new
            else
                aborting "[ERROR] can't find ${ipset_families_save}"
            fi
        done
        unset ip_families

        lablLoadBlacklists blacklist
        lablLoadWhitelists whitelist

        local blacklist
        for blacklist in ${Blacklists[@]}; do
            debug "$FUNCNAME blacklist = $blacklist" 50

            if ipv4Valid "$blacklist"; then
                local ip_family=("inet")
            else
                if ipv4ValidCidr "$blacklist"; then
                    local ip_family=("inet")
                else
                    local ip_family=("inet6")
                fi
            fi

            if [ "$ip_family" != "" ]; then
                local ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
                echo add labl_inet $blacklist | sed -e '/\/32/s///g' >> ${ipset_family_save}.new
            fi

        done

        local ip_families
        for ip_families in ${IP_Families[@]}; do
            local ipset_families_save="${ipset_save}.${Ipset_Name}_${ip_families}"
            sort -ruV ${ipset_families_save}.new -o ${ipset_families_save}.new
            local blacklist_add
            for blacklist_add in $(diff ${ipset_families_save} ${ipset_families_save}.new 2> /dev/null | grep ^\> | awk '{print $NF}'); do
                if [[ "$blacklist_add" != *"/"* ]]; then
                    lablAdd ${blacklist_add}/32 blacklist
                else
                    lablAdd $blacklist_add blacklist
                fi
            done
            unset blacklist_add
        done
        unset ip_families

    fi
}


# check if an ip address or range is in an ipset
function lablCheck() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        local blacklist=0
        local whitelist=0
    fi

    if [ "$3" == "quiet" ]; then
        local quiet=0
    else
        local quiet=1
    fi

    debug "ip_families = ${ip_families[@]}" 7
    if ipv4Valid "$ip"; then
        local ip_families=("inet")
    else
        if ipv4ValidCidr "$ip"; then
            local ip_families=("inet")
        else
            if ipv6Valid "$ip"; then
                local ip_families=("inet6")
            else
                if ipv6ValidCidr "$ip"; then
                    local ip_families=("inet6")
                else
                    local ip_families=(${IP_Families[@]})
                fi
            fi
        fi
    fi
    debug "ip_families = ${ip_families[@]}" 7

    local ip_family
    for ip_family in ${ip_families[@]}; do

        let blacklisted=1
        let whitelisted=1
        #let quiet=1

        if [ $whitelist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) whitelist" 5
            # nomatch tests are true for both 'nomatch' rules and absence of specific match rules
            # TODO; fix stdout ... misleading
            ipset test ${Ipset_Name}_${ip_family} $ip &> /dev/null
            if [ $? -ne 0 ]; then
                let whitelisted=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is whitelisted" CHECK
                fi
            else
                let whitelisted=1
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT whitelisted" CHECK
                fi
            fi
            if [ $blacklist -eq 1 ]; then
                return $whitelisted
            fi
        fi

        if [ $blacklist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) blacklist" 5
            ipset test ${Ipset_Name}_${ip_family} $ip &> /dev/null
            if [ $? -eq 0 ]; then
                let blacklisted=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is blacklisted" CHECK
                fi
            else
                let blacklisted=1
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT blacklisted" CHECK
                fi
            fi
            if [ $whitelist -eq 1 ]; then
                return $blacklisted
            fi
        fi
    done
    unset ip_family

    return 1
}

# check if an ip address or range is in a whitelist
function lablCheckWhitelists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi
    debug "$FUNCNAME ip = $ip" 14

    lablLoadWhitelists

    local ip_range=$(subnetcalc $ip -n -nocolor 2> /dev/null | grep ^Host\ Range)
    debug "$FUNCNAME ip_range = $ip_range" 10

    local whitelist_cidr="32"
    let local whitelist_match=1

    local whitelist
    for whitelist in ${Whitelists[@]}; do
        debug "$FUNCNAME whitelist = $whitelist" 10

        local whitelist_cidr=${whitelist##*/} # ${0##*/}
        if [ "$whitelist_cidr" == "$whitelist" ]; then
            debug "$FUNCNAME [WARNING] whitelist_cidr == whitelist $whitelist" 10
            continue
        fi

        debug "$FUNCNAME " 20
        debug "$FUNCNAME ip = $ip, whitelist = $whitelist, whitelist_cidr = $whitelist_cidr" 14
        debug "$FUNCNAME " 20

        # perfect match
        if [ "$ip" == "$whitelist" ]; then
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist [MATCH, PERFECT]" 22
            let local whitelist_match=0
            break
        fi

        # if it's not a perfect match, checking other /32's is pointless
        if [ "$whitelist_cidr" == "32" ]; then
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist [SKIP, IMPOSSIBLE]" 22
            continue
        fi

        debug "$FUNCNAME ip = $ip, whitelist = $whitelist [OK, CHECK]" 22

        # strip the mask off the ip, replace it with the whitelist mask, & compare ranges
        ip_whitelist=${ip%%/*}
        ip_whitelist+="/$whitelist_cidr"
        local whitelist_range=$(subnetcalc $whitelist -n -nocolor 2> /dev/null | grep ^Host\ Range)
        local ip_whitelist_range=$(subnetcalc $ip_whitelist -n -nocolor 2> /dev/null | grep ^Host\ Range)
        if [ "$whitelist_range" == "$ip_whitelist_range" ]; then
            let local whitelist_match=0
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist [MATCH, RANGE]" 22
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist ip_whitelist = $ip_whitelist" 14
            debug "$FUNCNAME ip_whitelist_range = $ip_whitelist_range ($ip_whitelist)" 14
            break
        fi

        debug "$FUNCNAME ip_range           = $ip_range ($ip)" 14
        debug "$FUNCNAME whitelist_range    = $whitelist_range ($whitelist)" 14
    done
    unset whitelist

    if [ $whitelist_match -eq 0 ]; then
        debug "$FUNCNAME ip = $ip AND whitelist = $whitelist [MATCH]" 5
        _echo "$ip is whitelisted" NOTICE
        return 0
    fi

    return 1

    # TODO better ipv6 whitelist support
}

# output list of standard locations found for a given filename that's readable
function lablFindLists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local find_lists="$1"
    if [ "$find_lists" == "" ]; then
        debug "$FUNCNAME passed no arguments to $FUNCNAME" 1
        return 1
    fi

    debug "$FUNCNAME find_lists = '$find_lists'" 33

    local labl_etc_d=$(dirname $(dirname $Zero) 2> /dev/null)/etc/labl.d/

    local find_dirs=()
    find_dirs+=(/etc/labl.d)
    find_dirs+=($labl_etc_d)

    local found_lists=()
    for find_dir in ${find_dirs[@]}; do
        debug "$FUNCNAME find_dir = $find_dir" 32
        if [ -r "$find_dir" ]; then
            local candidate
            while read candidate; do
                if [ -r $candidate ]; then
                    debug "$FUNCNAME candidate = $candidate (readable)" 30
                    found_lists+=($candidate)
                else
                    debug "$FUNCNAME candidate = $candidate (not readable)" 30
                fi
            done <<< "$(find "${find_dir}" -name "*${find_lists}*" 2> /dev/null | sort -u)"
            unset candidate
        fi
    done

    debug "$FUNCNAME found_lists = '$find_lists' = $(echo ${found_lists[@]})" 13

    if [[ "${found_lists[@]}" ]]; then
        echo "${found_lists[@]}"
        return 0
    fi

    return 1
}

# initialize all dependencies, etc.
function lablInit() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    # ensure executable dependencies are available
    Dependencies=()
    Dependencies+=(awk)
    Dependencies+=(basename)
    Dependencies+=(cut)
    Dependencies+=(date)
    Dependencies+=(dirname)
    Dependencies+=(find)
    Dependencies+=(ipset)
    Dependencies+=(iptables)
    Dependencies+=(ip6tables)
    Dependencies+=(printf)
    Dependencies+=(readlink)
    Dependencies+=(subnetcalc) # subnetcalc
    Dependencies+=(sed)
    Dependencies+=(sort)

    local dependency
    for dependency in ${Dependencies[@]}; do
        which $dependency &> /dev/null
        if [ $? -ne 0 ]; then
            aborting "FAILED which dependency '$dependency'" 3
        fi
    done
    unset dependency

    Basename_0=$(basename $0)
    Dirname_0="$(dirname $0)"

    if [ "$Dirname_0" == "." ]; then
        Dirname_0="$PWD"
    fi

    Zero="$Dirname_0/$Basename_0"

    if [ -r "${Dirname_0}/../include/debug-bash/Debug.bash" ]; then
        source "${Dirname_0}/../include/debug-bash/Debug.bash"
    fi

    debug "0 = $0" 5
    debug "Debug = $Debug" 1
    debug "Basename_0 = $Basename_0" 1
    debug "Dirname_0 = $Dirname_0" 5
    debug "Zero = $Zero" 1

    if [ "$Basename_0" == "blacklist" ]; then
        Ipset_Mode="blacklist"
    fi

    if [ "$Basename_0" == "whitelist" ]; then
        Ipset_Mode="whitelist"
    fi

    # evaluate usage flag as sym link or option (arg 1)
    Flag=$(printf "$Basename_0" | awk -F- '{print $2}')
    if [ "$Flag" == "" ]; then
        Flag="$1"
        let Valid_Flag=1
        if [ "$Flag" != "" ]; then

            for Option in ${Options[@]}; do
                if [ "$Flag" == "$Option" ]; then
                    let Valid_Flag=0
                    break;
                fi
            done

            if usageOptionSingle $Option; then
                if [ "$Ipset_Mode" == "" ]; then
                    Ipset_Mode="$2"
                fi
            else
                IP_Address="$2"
                if [ "$Ipset_Mode" == "" ]; then
                    Ipset_Mode="$3"
                fi
            fi
        else
            IP_Address="$1"
            if [ "$Ipset_Mode" == "" ]; then
                Ipset_Mode="$2"
            fi
        fi

        if [ $Valid_Flag -eq 1 ]; then
            if [ "$Flag" == "" ]; then
                debug "$FUNCNAME no flag" 14
                usage
            else
                Flag=""
                usage "invalid flag"
            fi
        fi

        debug "$FUNCNAME Option = $Option (Flag)" 14
    else
        IP_Address="$1"
        if [ "$Ipset_Mode" == "" ]; then
            Ipset_Mode="$2"
        fi
    fi
    debug "$FUNCNAME Flag = $Flag" 14

    if usageOptionSingle $Option; then
        IP_Address=""
    else
        debug "IP_Address = $IP_Address" 1

        if ! ipValid "$IP_Address"; then
            if [ "$IP_Address_Family" == "hostname" ]; then
                usage "hostnames are NOT supported"
            else
                usage "invalid IP address or CIDR range '$IP_Address'"
            fi
        fi

    fi

    # no flag or option, basic usage
    if [ "$Flag" == "" ]; then
        usage
    fi

    if [ "$Ipset_Mode" != "whitelist" ]; then
        Ipset_Mode="blacklist"
    fi
    debug "$FUNCNAME Ipset_Mode = $Ipset_Mode" 5

    Ipset_Version=$(ipset -v 2> /dev/null | awk -F, '{print $1}')
    local -i ipset_version_major=$(echo $Ipset_Version | sed '/[a-z]/s///g' |  awk -F. '{print $1}')
    local -i ipset_version_minor=$(echo $Ipset_Version | sed '/[a-z]/s///g' |  awk -F. '{print $2}')
    # TODO; verify exactly which version of ipset starts supporting nomatch & enhance this to allow versions greater than that
    if [ $ipset_version_major -ge 6 ] && [ $ipset_version_minor -ge 19 ]; then
        let Ipset_Nomatch=0
    else
        let Ipset_Nomatch=1
    fi
    debug "Ipset_Version = $Ipset_Version ($Ipset_Nomatch) [$ipset_version_major][$ipset_version_minor]" 1

    if [ "$Ipset_Name" == "" ]; then
        aborting "Ipset_Name is empty" 3
    fi
    debug "$FUNCNAME Ipset_Name = $Ipset_Name" 14

    Readlink_0=$(readlink -e $Zero 2> /dev/null)
    if [ "$Readlink_0" == "" ]; then
        aborting "Readlink_0 Zero failed" 3
    fi
    debug "$FUNCNAME Readlink_0 = $Readlink_0" 1

    Timestamp=$(date +%Y%m%d%H%M%S.%N)
    debug "$FUNCNAME Timestamp = $Timestamp" 14

    if [ "$Tmp_Dir" == "" ]; then
        Tmp_Dir="/var/tmp"
    fi

    if [ ! -d "$Tmp_Dir" ]; then
        mkdir -p "$Tmp_Dir"
        if [ $? -ne 0 ]; then
            aborting "failed to make temp directory '$Tmp_Dir'"
        fi
    fi

    if [ ! -d "$Tmp_Dir" ] || [ ! -w "$Tmp_Dir" ]; then
        aborting "'$Tmp_Dir' temporary directory not writable"
    fi

    Tmp_File=${Tmp_Dir}/${Basename_0}.${Timestamp}
    debug "$FUNCNAME Tmp_File = $Tmp_File" 14
}

# load lists of validated ips from file(s)
function lablLoad() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        debug "$FUNCNAME passed no arguments to $FUNCNAME" 14
        return 1
    fi

    debug "$FUNCNAME arguments = $(echo $@)" 18

    local load_files=()

    local load_candidates=($@)
    for load_candidate in ${load_candidates[@]}; do
        debug "$FUNCNAME load_candidate = ${load_candidate}" 14
        if [ -r $load_candidate ]; then
            debug "$FUNCNAME load_candidate = $load_candidate (readable)" 33
            load_files+=($load_candidate)
        else
            debug "$FUNCNAME load_candidate = $load_candidate (not readable)" 33
        fi
        unset load_candidate
    done
    debug "$FUNCNAME load_files = $(echo ${load_files[@]})" 10

    # pre-load ip(s)

    if [[ "${load_files[@]}" ]]; then

        local load_candidates=()

        local load_file
        for load_file in ${load_files[@]}; do
            if [ -r "${load_file}" ]; then
                local load_script=$(head -1 "${load_file}" 2> /dev/null | grep ^"#!")
                if [ "${load_script}" != "" ]; then
                    debug "$FUNCNAME load_file = $load_file (execute)" 10
                    local load_line
                    while read load_line; do
                        load_candidates+=($load_line)
                    done <<< "$(bash "$load_file" | egrep -e '^[0-9]|^[a-f]|^[A-F]')"
                    unset load_line
                else
                    debug "$FUNCNAME load_file = $load_file (cat)" 10
                    local load_line
                    while read load_line; do
                        load_candidates+=($load_line)
                    done <<< "$(cat "$load_file" | egrep -e '^[0-9]|^[a-f]|^[A-F]')"
                    unset load_line
                fi
            fi
        done
        unset load_file

        local load_ips=()

        local load_candidates_uniq=($(printf "%s\n" ${load_candidates[@]} | sort -Vu))
        load_candidates=(${load_candidates_uniq[@]})
        unset load_candidates_uniq

        local load_candidate
        for load_candidate in ${load_candidates[@]}; do
            # skip empty lines
            if [ "${load_candidate}" == "" ]; then
                continue
            fi

            # skip comments
            if [ "${load_candidate:0:1}" == "#" ]; then
                continue
            fi

            debug "$FUNCNAME load_candidate = $load_candidate" 30

            let local valid_load_candidate=1
            if ipv4Valid "$load_candidate"; then
                let local valid_load_candidate=0
                if [[ "$load_candidate" != *"/"* ]]; then
                    load_candidate+="/32"
                fi
            else
                if ipValid "$load_candidate"; then
                    let local valid_load_candidate=0
                fi
            fi

            if [ $valid_load_candidate -eq 0 ]; then
                debug "$FUNCNAME valid load ip = $load_candidate" 7
                load_ips+=($load_candidate)
            else
                if [ $Status_Flag -eq 1 ] ; then
                    _echo "ignoring invalid IP '$load_candidate' in $(grep -Fl $load_candidate ${load_files[@]})" WARNING
                fi
            fi

        done
        unset load_candidate

        if [[ "${load_ips[@]}" ]]; then
            echo "${load_ips[@]}"
            return 0
        fi
    fi

    return 1
}

# load named blacklists into global $Blacklists & $Blacklists_Files
function lablLoadBlacklists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local -l list_labl=blacklist
    else
        list_labl="$1"
    fi
    debug "$FUNCNAME list_labl = $list_labl" 14

    if [[ ${Blacklists[@]} ]]; then
        if [[ ${Blacklists_Files[@]} ]]; then
            debug "$FUNCNAME blacklists already loaded" 10
            return 0
        fi
    fi

    Blacklists_Files=($(lablFindLists $list_labl))
    debug "$FUNCNAME Blacklists_Files = $(echo ${Blacklists_Files[@]})" 10

    Blacklists=()
    if [ "$Blacklists_Files" != "" ]; then
        local blacklist
        for blacklist in $(lablLoad "${Blacklists_Files[@]}"); do
            debug "$FUNCNAME blacklist = $blacklist" 13
            Blacklists+=($blacklist)
        done
        unset blacklist
    fi

    if [[ ${Blacklists[@]} ]]; then
        if [[ ${Blacklists_Files[@]} ]]; then
            local blacklist_from
            for  blacklist_from in ${Blacklists_Files[@]}; do
                if [ $Verbose_Flag -eq 0 ] || [ "$2" == "verbose" ]; then
                    _echo "blacklist loaded from $blacklist_from" OK
                fi
            done
            unset blacklist_from
            return 0
        fi
    fi

    return 1
}

# load named whitelists into global $Whitelists & $Whitelists_Files
function lablLoadWhitelists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local -l list_labl=whitelist
    else
        list_labl="$1"
    fi
    debug "$FUNCNAME list_labl = $list_labl" 14

    if [[ ${Whitelists[@]} ]]; then
        if [[ ${Whitelists_Files[@]} ]]; then
            debug "$FUNCNAME whitelists already loaded" 10
            return 0
        fi
    fi

    Whitelists_Files=($(lablFindLists $list_labl))
    debug "$FUNCNAME Whitelists_Files = $(echo ${Whitelists_Files[@]})" 10

    Whitelists=()
    if [ "$Whitelists_Files" != "" ]; then
        local whitelist
        for whitelist in $(lablLoad "${Whitelists_Files[@]}"); do
            debug "$FUNCNAME whitelist = $whitelist" 13
            Whitelists+=($whitelist)
        done
        unset whitelist
    fi

    if [[ ${Whitelists[@]} ]]; then
        if [[ ${Whitelists_Files[@]} ]]; then
            local whitelist_from
            for  whitelist_from in ${Whitelists_Files[@]}; do
                if [ $Verbose_Flag -eq 0 ]; then
                    _echo "whitelist loaded from $whitelist_from" OK
                fi
            done
            unset whitelist_from
            return 0
        fi
    fi

    return 1
}

# remove an ip address or range from an ipset
function lablRemove() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 14
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        local blacklist=0
        local whitelist=0
    fi

    if [ "$3" == "quiet" ]; then
        local quiet=0
    else
        local quiet=1
    fi

    if ipv4Valid "$ip"; then
        local ip_families=("inet")
    else
        if ipv4ValidCidr "$ip"; then
            local ip_families=("inet")
        else
            if ipv6Valid "$ip"; then
                local ip_families=("inet6")
            else
                if ipv6ValidCidr "$ip"; then
                    local ip_families=("inet6")
                else
                    local ip_families=(${IP_Families[@]})
                fi
            fi
        fi
    fi
    debug "ip_families = ${ip_families[@]}" 7

    for ip_family in ${ip_families[@]}; do

        local blacklist_removed=1
        local whitelist_removed=1
        #local quiet=1

        if [ $blacklist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) blacklist" 14

            if lablCheck "$ip" blacklist quiet; then
                ipset del ${Ipset_Name}_${ip_family} $ip
                if lablCheck "$ip" blacklist quiet; then
                    _echo "$ip is still in blacklist (manually check the CIDR ranges)" WARNING
                else
                    local blacklist_removed=0
                    if [ $quiet -eq 1 ]; then
                        _echo "$ip removed from blacklist" REMOVE
                    fi
                fi
            else
                local blacklist_removed=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT in blacklist" REMOVE
                fi
            fi

            if [ $blacklist -eq 1 ] && [ $whitelist -eq 0 ]; then
                return $blacklist_removed
            fi
        fi

        if [ $whitelist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) whitelist" 14

            if lablCheck "$ip" whitelist quiet; then
                ipset del ${Ipset_Name}_${ip_family} $ip
                if lablCheck "$ip" whitelist quiet; then
                    _echo "$ip is still in whitelist (manually check the CIDR ranges)" WARNING
                else
                    local whitelist_removed=0
                    if [ $quiet -eq 1 ]; then
                        _echo "$ip removed from whitelist" REMOVE
                    fi
                fi
            else
                local whitelist_removed=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT in whitelist" REMOVE
                fi
            fi

            if [ $blacklist -eq 0 ] && [ $whitelist -eq 1 ]; then
                return $blacklist_removed
            fi
        fi

    done

}

# restore ipsets
function lablRestore() {
    debug "$FUNCNAME Function = $FUNCNAME" 50
}

# save ipsets
function lablSave() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ipset_save="${Tmp_File}.save"
    else
        local ipset_save="$1"
    fi

    if [ "$ipset_save" == "" ]; then
        debug "$FUNCNAME ipset_save is empty" 14
        return 1
    fi

    local ip_families=(${IP_Families[@]})
    for ip_family in ${ip_families[@]}; do
        ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
        if [ $Auto_Flag -eq 1 ]; then
            _echo "ipset save ${Ipset_Name}_${ip_family} to $ipset_family_save" SAVE
        fi
        ipset save ${Ipset_Name}_${ip_family} | sort -ruV > "$ipset_family_save"
    done

}

# check & if needed, create ipsets and iptables/ip6tables rules
function lablStart() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local rc=0

    local ip_families=(${IP_Families[@]})
    for ip_family in ${ip_families[@]}; do
        if [ "$ip_family" == "inet" ]; then
            table_exec="iptables"
        else
            table_exec="ip6tables"
        fi

        debug "$FUNCNAME check $table_exec $ip_family ipset" 10

        # if needed, create ${ip_family} set
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -ne 0 ]; then
            # set doesn't exist, create it
            local ipset_type="hash:net"
            ipset -q create ${Ipset_Name}_${ip_family} $ipset_type hashsize $Ipset_Hashsize maxelem $Ipset_Maxelem family ${ip_family}
            if [ $? -eq 0 ]; then
                _echo "ipset ${Ipset_Name}_${ip_family} created" OK
            else
                aborting "[ERROR] FAILED to ipset create ${Ipset_Name}_${ip_family} $ipset_type hashsize $Ipset_Hashsize maxelem $Ipset_Maxelem family ${ip_family}" 3
            fi
        else
            # set exists, great
            if [ $Verbose_Flag -eq 0 ]; then
                _echo "ipset ${Ipset_Name}_${ip_family} exists" NOTICE
            fi
        fi

        debug "$FUNCNAME check $table_exec $ip_family rule" 10

        # iptables/ip6tables bug ...; sometimes results aren't produced on the first try ... :/
        local table_count=0

        let local table_try=3
        while [ $table_try -gt 0 ]; do
            if [ $table_count -eq 0 ]; then
                local table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            else
                break
            fi
            ((--table_try))
        done
        debug "$FUNCNAME $table_exec $ip_family table_try = $table_try" 10

        if [ $table_count -eq 0 ]; then
            # insert [first rule]
            $table_exec -I INPUT 1 -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP
            if [ $? -eq 0 ]; then
                _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} started" OK
            else
                aborting "[ERROR] FAILED to $table_exec -I INPUT 1 -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP" 3
            fi
        else
            if [ $table_count -eq 1 ]; then
                if [ $Verbose_Flag -eq 0 ]; then
                    _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} running" OK
                fi
            else
                aborting "[ERROR] $table_exec --match-set ${Ipset_Name}_${ip_family} is loaded $table_count times, try restarting" 3
            fi
        fi

    done

    if [ $Verbose_Flag -eq 0 ]; then
        printf "\n"
    fi

    lablLoadBlacklists blacklist
    lablLoadWhitelists whitelist

    if [ $Verbose_Flag -eq 0 ]; then
        printf "\n"
    fi

    if usageOptionSingle $Option; then

        # blacklisting first, rather than whitelisting, allows whitelists to override blacklists

        local blacklist
        for blacklist in ${Blacklists[@]}; do
            debug "$FUNCNAME blacklist = $blacklist" 10
            lablAdd $blacklist blacklist
        done
        unset blacklist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        local whitelist
        for whitelist in ${Whitelists[@]}; do
            debug "$FUNCNAME whitelist = $whitelist" 10
            lablAdd $whitelist whitelist
        done
        unset whitelist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        _echo "$Basename_0 start successful" "OK"
        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

    fi
}

# list contents of all ipsets & iptables rules
function lablStatus() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    Status_Flag=0

    let local labl_running=1

    local ipset_match=""
    if [ $Ipset_Nomatch -eq 0 ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local ipset_match="nomatch"
        fi
    fi

    local labl_inet_count=0
    local labl_inet_blacklist_count=0
    local labl_inet_whitelist_count=0

    local labl_inet6_count=0
    local labl_inet6_blacklist_count=0
    local labl_inet6_whitelist_count=0

    echo "----------------------------------------------------------------"
    local ip_families=(${IP_Families[@]})
    for ip_family in ${ip_families[@]}; do
        if [ "$ip_family" == "inet" ]; then
            table_exec="iptables"
        else
            table_exec="ip6tables"
        fi

        debug "$FUNCNAME check $table_exec $ip_family ipset" 10

        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -eq 0 ]; then
            let local labl_running=0

            ipset list ${Ipset_Name}_${ip_family} 2> /dev/null > /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
            if [ -r /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp} ]; then
                cat /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
            fi

            debug "$FUNCNAME check $table_exec $ip_family rule" 10

            # iptables/ip6tables bug ...; sometimes they doesn't produce results on the first try ...
            local table_count=0

            let local table_try=3
            while [ $table_try -gt 0 ]; do
                if [ $table_count -eq 0 ]; then
                    table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
                else
                    break
                fi
                ((--table_try))
            done
            debug "$FUNCNAME table_try = $table_try" 10
            echo
            if [ $table_count -eq 0 ]; then
                echo "[-] $table_exec --match-set ${Ipset_Name}_${ip_family} is NOT loaded"
            else
                if [ $table_count -eq 1 ]; then
                    echo "[+] $table_exec --match-set ${Ipset_Name}_${ip_family} is loaded"
                    echo
                else
                    echo "[WARNING] $table_exec --match-set ${Ipset_Name}_${ip_family} is loaded $table_count times"
                    echo
                fi

                lablLoadBlacklists blacklist
                lablLoadWhitelists whitelist

                if [[ ${Blacklists_Files[@]} ]]; then
                    echo "[+] Blacklists"
                    echo
                    local blacklists_file
                    for blacklists_file in ${Blacklists_Files[@]}; do
                        echo "$blacklists_file"
                        echo
                        Status_Flag=1
                        printf "%s\n" $(lablLoad $blacklists_file lablStatus)
                        Status_Flag=0
                        echo
                    done
                    unset blacklists_file
                    echo
                fi

                if [[ ${Whitelists_Files[@]} ]]; then
                    echo "[+] Whitelists"
                    echo
                    local whitelists_file
                    for whitelists_file in ${Whitelists_Files[@]}; do
                        echo "$whitelists_file"
                        echo
                        Status_Flag=1
                        printf "%s\n" $(lablLoad $whitelists_file lablStatus)
                        Status_Flag=0
                        echo
                    done
                    unset whitelists_file
                    echo
                fi

                local labl_blacklist_count=$(sed '1,/^Members:$/d' /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp} | grep -v nomatch | wc -l)
                if [ $labl_blacklist_count -eq 0 ]; then
                    if [[ ${Blacklists_Files[@]} ]]; then
                        if [ "${ip_family}" == "inet" ]; then
                            local labl_blacklist_count=$(cat ${Blacklists_Files[@]} | egrep "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]" | wc -l)
                        else
                            local labl_blacklist_count=$(cat ${Blacklists_Files[@]} | egrep -ve "^#|^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]" | wc -l)
                        fi
                    fi
                fi
                if [ "${ip_family}" == "inet" ]; then
                    let labl_inet_count=$labl_inet_count+$labl_blacklist_count
                    let labl_inet_blacklist_count=$labl_inet_blacklist_count+$labl_blacklist_count
                fi
                if [ "${ip_family}" == "inet6" ]; then
                    let labl_inet6_count=$labl_inet6_count+$labl_blacklist_count
                    let labl_inet6_blacklist_count=$labl_inet6_blacklist_count+$labl_blacklist_count
                fi

                local labl_whitelist_count=$(sed '1,/^Members:$/d' /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp} | grep nomatch | wc -l)
                if [ $labl_whitelist_count -eq 0 ]; then
                    if [[ ${Whitelists_Files[@]} ]]; then
                        if [ "${ip_family}" == "inet" ]; then
                            local labl_whitelist_count=$(cat ${Whitelists_Files[@]} | egrep "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]" | wc -l)
                        else
                            local labl_whitelist_count=$(cat ${Whitelists_Files[@]} | egrep -ve "^#|^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]" | wc -l)
                        fi
                    fi
                fi
                if [ "${ip_family}" == "inet" ]; then
                    let labl_inet_count=$labl_inet_count+$labl_whitelist_count
                    let labl_inet_whitelist_count=$labl_inet_whitelist_count+$labl_whitelist_count
                fi
                if [ "${ip_family}" == "inet6" ]; then
                    let labl_inet6_count=$labl_inet6_count+$labl_whitelist_count
                    let labl_inet6_whitelist_count=$labl_inet6_whitelist_count+$labl_whitelist_count
                fi

                echo
                echo "$labl_blacklist_count blacklisted & $labl_whitelist_count whitelisted ${ip_family} addresses and/or ranges"
                echo
            fi
            echo
        fi

        echo "----------------------------------------------------------------"
    done

    if [ $labl_running -eq 0 ]; then
        if [ $labl_inet_count -eq 0 ] && [ $labl_inet6_count -eq 0 ]; then
            echo "labl is running, nothing is being blacklisteded or whitelisted"
            echo
        else
            echo "$labl_inet6_blacklist_count blacklisted and $labl_inet6_whitelist_count whitelisted v6 IP addresses"
            echo "$labl_inet_blacklist_count blacklisted and $labl_inet_whitelist_count whitelisted v4 IP addresses"
            echo
            echo "labl is running, $labl_inet_count v4 and $labl_inet6_count v6 addresses in loaded lists"
            echo
        fi
    else
        echo
        echo "labl is NOT running, nothing is being ${Ipset_Mode}ed"
        echo
    fi

    exit 0
}

# remove all ip family rules & ipsets
function lablStop() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local rc=0

    local ip_families=(${IP_Families[@]})
    for ip_family in ${ip_families[@]}; do
        if [ "$ip_family" == "inet" ]; then
            table_exec="iptables"
        else
            table_exec="ip6tables"
        fi

        debug "$FUNCNAME check $table_exec $ip_family rule" 10

        # iptables/ip6tables bug ...; sometimes they doesn't produce results on the first try ...
        local table_count=0

        let local table_try=3
        let local table_try_max=10
        while [ $table_try -gt 0 ]; do
            if [ $table_count -eq 0 ]; then
                local table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            else
                break
            fi
            ((--table_try))
        done
        debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try" 10

        if [ $table_count -gt 0 ]; then
            let local table_try_max=$table_try_max+$table_count
        else
            let local table_try_max=0
        fi

        let table_stopped=0
        if [ $table_count -gt 0 ]; then
            while [ $table_try_max -gt 0 ]; do
                debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try, table_try_max = $table_try_max" 10
                $table_exec -D INPUT 1 -m set --match-set ${Ipset_Name}_${ip_family} src &> /dev/null
                if [ $? -eq 0 ]; then
                    let table_stopped=$table_stopped+1
                fi
                ((--table_try_max))
            done
        else
            debug "$FUNCNAME $table_exec --match-set ${Ipset_Name}_${ip_family} stopped" 10
        fi

        # second time, check to be sure it's stopped
        local table_count=0

        let local table_try=3
        while [ $table_try -gt 0 ]; do
            if [ $table_count -eq 0 ]; then
                local table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            else
                break
            fi
            ((--table_try))
        done
        debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try" 10

        if [ $table_count -gt 0 ]; then
            _error "FAILED to remove $table_exec --match-set ${Ipset_Name}_${ip_family}" ERROR
            rc=4
        else
            if [ $table_stopped -gt 0 ]; then
                _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} stopped" OK
            else
                _echo "[-] $table_exec --match-set ${Ipset_Name}_${ip_family} NOT loaded" NOTICE
            fi
        fi

        # check ${ip_family} set
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -eq 0 ]; then
            ipset -q destroy ${Ipset_Name}_${ip_family}
            if [ $? -eq 0 ]; then
                _echo "destoyed ipset ${Ipset_Name}_${ip_family}" OK
            else
                _error "FAILED to destoy ipset ${Ipset_Name}_${ip_family}" ERROR
                rc=4
            fi
        else
            _echo "ipset ${Ipset_Name}_${ip_family} NOT loaded" NOTICE
        fi

    done

    if [ -f "${Tmp_File}" ]; then
        rm -f "${Tmp_File}" &> /dev/null
    fi

    if [ $rc -ne 0 ]; then
        _error "FAILED to $Basename_0 $Option" ERROR
        exit $rc
    else
        if usageOptionSingle $Option; then
            _echo "$Basename_0 stop successful" "OK"
        fi
    fi

}

# cli usage
function usage() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local ip_address="<ip|ip/cidr>"

    local usage_header="usage: $Basename_0"
    local usage_footer=" [blacklist|whitelist] # optional, blacklist is default"
    if [ "$Flag" == "" ]; then
        local usage_message="$usage_header <"
        for Option in ${Options[@]}; do
            # these options do NOT require an ip|ip/cdr
            if usageOptionSingle $Option; then
                continue
            fi
            usage_message+="$Option|"
        done
        unset Option
        usage_message=$(printf "$usage_message" | sed -e '/|$/s///g')
        usage_message+="> $ip_address"
        if [ "$Ipset_Mode" == "" ]; then
            local usage_message+=$usage_footer
        fi
        usage_message+="\n-or-\n$usage_header <auto|restart|start|status|stop>"
    else
        if [ "$Option" == "$Flag" ]; then
            local usage_message="$usage_header $Option $ip_address"
        else
            local usage_message="$usage_header $ip_address"
        fi
        if [ "$Ipset_Mode" == "" ]; then
            local usage_message+=$usage_footer
        fi
    fi
    if [ "$1" != "" ]; then
        usage_message+="\n\nNOTE: $@"
    fi
    printf "\n$usage_message\n\n"

    exit 1
}

# cli usage options that don't require any extra arguments
function usageOptionSingle() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local option="$1"

    if [ "$option" == "auto" ] || [ "$option" == "restart" ] || [ "$option" == "save" ] || [ "$option" == "start" ] || [ "$option" == "status" ] || [ "$option" == "stop" ]; then
        return 0
    fi

    return 1
}

# Main

lablInit $@

# supported options without other arguments are restart, start, status, stop

# status is a special option, exit
Status_Flag=1 # 0=true, 1=false
if [ "$Option" == "status" ]; then
    Status_Flag=0
    lablStatus
    exit
fi

# start is a special option, exit
Start_Flag=1 # 0=true, 1=false
if [ "$Option" == "start" ]; then
    Start_Flag=0 # 0=true, 1=false
    lablStart
    exit
fi

# stop is a special option, exit
Stop_Flag=1 # 0=true, 1=false
if [ "$Option" == "stop" ]; then
    Stop_Flag=0 # 0=true, 1=false
    lablStop
    exit
fi

# restart is a special option, exit
Restart_Flag=1 # 0=true, 1=false
if [ "$Option" == "restart" ]; then
    Restart_Flag=0 # 0=true, 1=false
    lablStop
    lablStart
    exit
fi

Save_Flag=1 # 0=true, 1=false
if [ "$Option" == "save" ]; then
    Save_Flag=0 # 0=true, 1=false
    lablSave "$IP_Address"
    exit
fi

Remove_Flag=1 # 0=true, 1=false
# auto is super special, it requires lablStart but no IP validation
Auto_Flag=1 # 0=true, 1=false
if [ "$Option" == "auto" ]; then
    Auto_Flag=0 # 0=true, 1=false
    lablAuto
else
    # all other supported options require a valid(ated) IP Address, ipset(s), and iptables/ip6tables rules
    lablStart
fi

Add_Flag=1 # 0=true, 1=false
if [ "$Option" == "add" ]; then
    Add_Flag=0 # 0=true, 1=false
    lablAdd "$IP_Address" "$Ipset_Mode"
    exit
fi

Check_Flag=1 # 0=true, 1=false
if [ "$Option" == "check" ]; then
    Check_Flag=0 # 0=true, 1=false
    lablCheck "$IP_Address"
    exit
fi

if [ "$Option" == "remove" ]; then
    Remove_Flag=0 # 0=true, 1=false
    lablRemove "$IP_Address"
    exit
fi

#
# Copyright (C) 2018, Joseph Tingiris
#
