#!/bin/bash

#
# This script uses the standard Linux utilities ipset & iptables/ip6tables to create a high performance IP blacklist.
#
# 20180727, jtingiris, v0.0.1 created
# 20181010, jtingiris, v0.0.2 updated
#
# References
#
# http://ipset.netfilter.org/ipset.man.html#lbAN
# EL 6 ipset doesn't support nomatch https://bugzilla.redhat.com/show_bug.cgi?id=1402201

PATH=/usr/bin:/usr/sbin:/bin:/sbin

# Globals

Verbose_Flag=1 # 0=on, 1=off

Options=()
Options+=(add)
Options+=(auto)
Options+=(check)
Options+=(iptables)
Options+=(remove)
Options+=(restart)
#Options+=(restore) # TODO; support this
Options+=(save)
Options+=(start)
Options+=(status)
Options+=(stop)

Blacklist_Permanent_File=/etc/labl.d/blacklist.permanent
Blacklist_Permanent_Max=15 # how many IPs on a subnet need to be abusive to qualify for notification

Ipset_Name="labl" # The ipset name(s) prefix.

Ipset_Hashsize=2048 # The initial hash size for Ipset_Name, default is 1024. The hash size must be a power of two, the kernel automatically rounds up non power of two hash sizes to the first correct value.  As more items are added to the ip set, the hash size will grow dynamically by doubling this value when/if needed..

Ipset_Maxelem=131072 # The maximum number of elements/entries in the ipset, default is 65536.  TODO; test max sizes

if [ "$DEBUG" == "" ]; then
    if [ "$Debug" == "" ]; then
        let Debug=0 # 0 disables debug
    else
        let Debug=$Debug # ensure it's an integer
    fi
else
    let Debug=$DEBUG+0
fi

# print formatted output to stdout
function _echo() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$2" == "" ]; then
        local echo_status="OK"
    else
        local echo_status="$2"
    fi

    local pad=11
    let local pad_left=(${pad}-${#echo_status})/2
    if [ ${pad_left} -lt 0 ]; then pad_left=1; fi
    let local pad_right=(${pad}-${#echo_status})-${pad_left}
    if [ ${pad_right} -lt 0 ]; then pad_right=1; fi

    (>&2 printf "$(date) : [%${pad_left}.s%s%${pad_right}.s] : %s\n" $pad_left "$echo_status" $pad_right "$1")

}

# print formatted output to stderr
function _error() {
    RC=1

    if [ "$2" == "" ]; then
        local error_level="ERROR"
    else
        local error_level="$2"
    fi

    _echo "$1" "$error_level"
}

# exit with a message and non-zero return code
function aborting() {
    printf "\naborting ... $@"
    printf "\n\n"
    if [[ $2 == '^[0-9]+$' ]]; then
        RC=$2
    else
        RC=2
    fi
    exit $RC
}

# print debug output to stderr if global debug is greater than or equal to local debug_level
function debug() {
    if [ $Debug -eq 0 ]; then
        return
    fi

    local debug_message=$1
    local debug_level=$(echo "$2" |  sed "s/[^0-9]//g")

    if [ "$debug_level" == "" ]; then
        local -i debug_level=0 # default debug level is 0
    fi

    if [ $Debug -ge $debug_level ]; then
        _echo "$debug_message" "DEBUG(${Debug},${debug_level})"
    fi
}

# validate 'IP_Address' & set global IP_Address_Family if it passes
function ipValid() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local ip_address="$1"

    debug "$FUNCNAME ip_address = $ip_address" 34

    # the rest of the options require an ip|ip/cidr, so that must be validated ...
    if [ "$ip_address" == "" ]; then
        _echo "empty ip_address passed to $FUNCNAME" WARNING
        return 1
    else

        if [ "$IP_Address_Family" == "" ]; then
            if ipv4Valid "$ip_address"; then
                debug "$FUNCNAME Valid IPv4 IP Address" 34
                IP_Address_Family="inet"
            else
                debug "$FUNCNAME Invalid IPv4 IP Address" 33
            fi
        fi

        if [ "$IP_Address_Family" == "" ]; then
            if ipv4ValidCidr "$ip_address"; then
                debug "$FUNCNAME Valid IPv4 CIDR Range" 34
                IP_Address_Family="inet"
            else
                debug "$FUNCNAME Invalid IPv4 CIDR Range" 33
            fi
        fi

        if [ "$IP_Address_Family" == "" ]; then
            if ipv6Valid "$ip_address"; then
                debug "$FUNCNAME Valid IPv6 IP Address" 34
                IP_Address_Family="inet6"
            else
                debug "$FUNCNAME Invalid IPv6 IP Address" 33
            fi
        fi

        if [ "$IP_Address_Family" == "" ]; then
            if ipv6ValidCidr "$ip_address"; then
                debug "$FUNCNAME Valid IPv6 CIDR Range" 34
                IP_Address_Family="inet6"
            else
                debug "$FUNCNAME Invalid IPv6 CIDR Range" 33
            fi
        fi

        if [ "$IP_Address_Family" == "" ]; then
            debug "$FUNCNAME invalid IP_Address_Family $IP_Address_Family" 33
            if [ "$IP_Address_Family" == "" ]; then
                if [ $Status_Flag -eq 1 ]; then
                    _echo "empty IP_Address_Family in $FUNCNAME" WARNING
                fi
            fi
            return 1
        else
            debug "$FUNCNAME IP_Address_Family = $IP_Address_Family" 33
        fi
    fi

    debug "$FUNCNAME ip_address = $ip_address" 33

    return 0

}

# regex for IPv4 validation
function ipv4Valid() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ $IP4 -eq 1 ]; then
        return 1
    fi

    local inet=${1}

    if [[ $inet =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        if [[ $inet =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ ]]; then
            return 0
        fi
    fi

    return 1

}

# regex for IPv4 CIDR validation
function ipv4ValidCidr() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ $IP4 -eq 1 ]; then
        return 1
    fi

    local inet_range=${1}

    if [[ $inet_range =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$ ]]; then
        return 0
    fi

    return 1
}

# regex for IPv6 validation
function ipv6Valid() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ $IP6 -eq 1 ]; then
        return 1
    fi

    local inet6=${1}

    if [[ $inet6 =~ ^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s* ]]; then
        return 0
    fi

    return 1
}

# regex for IPv6 CIDR validation
function ipv6ValidCidr() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ $IP6 -eq 1 ]; then
        return 1
    fi

    local inet6_range=${1}

    if [[ $inet6_range =~ ^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\/(d|dd|1[0-1]d|12[0-8]))$ ]]; then
        return 0
    fi

    return 1
}

# add an ip address or range to the appropriate ipset
function lablAdd() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local ip="$1"
    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi

    if ! ipValid "$ip"; then
        debug "$FUNCNAME ip $ip is invalid" 1
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        _echo "$FUNCNAME ip $ip is being whitelisted THEN blacklisted (this hasn't been fully tested!)" WARNING
        local whitelist=0
        local blacklist=0
    fi

    # ip_families is local here because the given ip may be either a v4 inet addres *or* a v6 inet6 address (or maybe both)
    if ipv4Valid "$ip"; then
        local ip_families=("inet")
    else
        if ipv4ValidCidr "$ip"; then
            local ip_families=("inet")
        else
            if ipv6Valid "$ip"; then
                local ip_families=("inet6")
            else
                if ipv6ValidCidr "$ip"; then
                    local ip_families=("inet6")
                else
                    local ip_families=(${IP_Families[@]})
                fi
            fi
        fi
    fi
    debug "ip_families = ${ip_families[@]}" 7

    local ip_family
    for ip_family in ${ip_families[@]}; do

        local blacklisted=1
        local whitelisted=1

        # whitelist first
        if [ $whitelist -eq 0 ]; then

            debug "$FUNCNAME ip = $ip ($ip_family) $whitelist whitelist" 14

            # remove it from blacklist
            if lablCheck "$ip" blacklist quiet; then

                debug "$FUNCNAME $ip exists in blacklist" 14

                if lablRemove "$ip" blacklist quiet; then
                    local blacklisted=1
                    _echo "$ip removed from blacklist" OK
                else
                    local blacklisted=0
                    _echo "$ip NOT removed from blacklist" NOTICE
                fi

                if lablCheck "$ip" blacklist quiet; then
                    local blacklisted=0
                    _echo "$ip NOT removed from blacklist" WARNING
                fi
            else
                local blacklisted=1
                debug "$FUNCNAME $ip is NOT in blacklist" 14
            fi

            if [ $blacklisted -eq 1 ]; then

                if [ "$Option" == "add" ]; then
                    if [ ! -d /etc/labl.d ]; then
                        mkdir -p /etc/labl.d &> /dev/null
                        if [ $? -ne 0 ]; then
                            aborting "[ERROR] mkdir -p /etc/labl.d failed"
                        fi
                    fi

                    if lablRemove "$ip" blacklist quiet; then
                        _echo "$ip removed from blacklist" OK
                    fi

                    echo "$ip" >> /etc/labl.d/whitelist.add
                    sort -uV /etc/labl.d/whitelist.add -o /etc/labl.d/whitelist.add
                fi

                if [ $Ipset_Nomatch -eq 0 ]; then
                    # add it to whitelist
                    # TODO; revisit this logic; explicit whitelisting or implicit??
                    #if lablCheck "$ip" whitelist quiet; then
                    #echo "[-] $ip exists in whitelist"
                    #else
                    # right now it's explicit ...
                    ipset -exist add ${Ipset_Name}_${ip_family} $ip nomatch &> /dev/null
                    if lablCheck "$ip" whitelist quiet; then
                        _echo "$ip added to whitelist" OK
                    else
                        _echo "$FUNCNAME $ip NOT added to whitelist" WARNING
                    fi
                    #fi
                    #else
                    #_echo "$ip NOT added to whitelist because $Ipset_Version does not support it" WARNING
                    # now it's possible to support adding to a whitelist file .. e.g. /etc/labl.d/whitelist.add
                fi
            else
                _echo "unable to whitelist $ip because it's currently blacklisted; try running '$Readlink_0 remove $ip blacklist'" WARNING
            fi

        fi

        # blacklist second
        if [ $blacklist -eq 0 ]; then

            debug "$FUNCNAME ip = $ip ($ip_family) $blacklist blacklist" 14

            # automating this part is subjective; works but needs work

            if lablCheckWhitelists "$ip"; then
                debug "$FUNCNAME $ip exists in a whitelist" 10
                _echo "$ip NOT blacklisted" NOTICE
                continue
            else
                debug "$FUNCNAME [ALLOWING] $ip is NOT in a whitelist" 10

                # if it's not in a whitelist, remove it from nomatch set?
                if [ "$Testing" != "" ]; then
                    if lablCheck "$ip" whitelist quiet; then

                        debug "$FUNCNAME $ip exists in whitelist" 14
                        local whitelisted=0

                        if lablRemove "$ip" whitelist quiet; then
                            _echo "$ip removed from whitelist" OK
                        else
                            _echo "$ip NOT removed from whitelist" NOTICE
                            local whitelisted=0
                        fi

                        if lablCheck "$ip" whitelist; then
                            debug "$FUNCNAME [WARNING] $ip NOT removed from whitelist" 2
                            local whitelisted=0
                        fi
                    else
                        debug "$FUNCNAME $ip is NOT in whitelist" 14
                        local whitelisted=0
                    fi
                fi
            fi

            # add it to blacklist
            if lablCheck "$ip" blacklist quiet; then
                _echo "$ip is already blacklisted" OK
            else
                ipset -exist add ${Ipset_Name}_${ip_family} $ip &> /dev/null
                if lablCheck "$ip" blacklist quiet; then
                    _echo "[+++] $ip added to blacklist" OK
                fi
            fi

        fi
    done
    unset ip_family

}

# automatically add *new* ip address(es) or range(s) to the appropriate ipset
function lablAuto() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    # check if labl is already running (properly)
    let local labl_running=0

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -ne 0 ]; then
            let local labl_running=1
        fi
    done
    unset ip_family

    # if it's not running properly, then restart, else add *only new* addresses to the ipsets
    if [ $labl_running -eq 1 ]; then
        lablStop
        lablStart
    else
        lablLoadWhitelists whitelist
        lablLoadBlacklists blacklist
    fi

    local ipset_save=/var/tmp/labl.auto.save
    lablSave $ipset_save

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        local ipset_families_save="${ipset_save}.${Ipset_Name}_${ip_family}"
        if [ -f "${ipset_families_save}" ]; then
            cp ${ipset_families_save} ${ipset_families_save}.new
        else
            aborting "[ERROR] can't find ${ipset_families_save}"
        fi
    done
    unset ip_family


    local blacklist
    for blacklist in ${Blacklists[@]}; do
        debug "$FUNCNAME blacklist = $blacklist" 50

        local ip_family

        if ipv4Valid "$blacklist"; then
            local ip_family=("inet")
        else
            if ipv4ValidCidr "$blacklist"; then
                local ip_family=("inet")
            else
                if [ $IP6 -eq 0 ]; then
                    local ip_family=("inet6")
                fi
            fi
        fi

        if [ "$ip_family" != "" ]; then
            local ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
            echo add labl_inet $blacklist | sed -e '/\/32/s///g' -e '/\/64/s///g' >> ${ipset_family_save}.new
        fi

        unset ip_family

    done

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        local ipset_families_save="${ipset_save}.${Ipset_Name}_${ip_family}"
        sort -ruV ${ipset_families_save}.new -o ${ipset_families_save}.new
        local blacklist_add
        for blacklist_add in $(diff ${ipset_families_save} ${ipset_families_save}.new 2> /dev/null | grep ^\> | awk '{print $NF}'); do
            lablAdd $blacklist_add blacklist
        done
        unset blacklist_add
    done
    unset ip_family

}


# check if an ip address or range is in an ipset
function lablCheck() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        local blacklist=0
        local whitelist=0
    fi

    if [ "$3" == "quiet" ]; then
        local quiet=0
    else
        local quiet=1
    fi

    # ip_families is local here because the given ip may be either a v4 inet addres *or* a v6 inet6 address (or maybe both)
    if ipv4Valid "$ip"; then
        local ip_families=("inet")
    else
        if ipv4ValidCidr "$ip"; then
            local ip_families=("inet")
        else
            if ipv6Valid "$ip"; then
                local ip_families=("inet6")
            else
                if ipv6ValidCidr "$ip"; then
                    local ip_families=("inet6")
                else
                    local ip_families=(${IP_Families[@]})
                fi
            fi
        fi
    fi
    debug "ip_families = ${ip_families[@]}" 7

    local ip_family
    for ip_family in ${ip_families[@]}; do

        let whitelisted=1
        let blacklisted=1
        #let quiet=1

        if [ $whitelist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) whitelist" 5
            # nomatch tests are true for both 'nomatch' rules and absence of specific match rules
            # TODO; fix stdout ... misleading
            ipset test ${Ipset_Name}_${ip_family} $ip &> /dev/null
            if [ $? -ne 0 ]; then
                let whitelisted=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is whitelisted" CHECK
                fi
            else
                let whitelisted=1
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT whitelisted" CHECK
                fi
            fi
            if [ $blacklist -eq 1 ]; then
                return $whitelisted
            fi
        fi

        if [ $blacklist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) blacklist" 5
            ipset test ${Ipset_Name}_${ip_family} $ip &> /dev/null
            if [ $? -eq 0 ]; then
                let blacklisted=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is blacklisted" CHECK
                fi
            else
                let blacklisted=1
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT blacklisted" CHECK
                fi
            fi
            if [ $whitelist -eq 1 ]; then
                return $blacklisted
            fi
        fi
    done
    unset ip_family

    return 1
}

# check if an ip address or range is in a whitelist
function lablCheckWhitelists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 1
        return 1
    fi
    debug "$FUNCNAME ip = $ip" 14

    lablLoadWhitelists whitelist

    local ip_range=$(subnetcalc $ip -n -nocolor 2> /dev/null | grep ^Host\ Range)
    debug "$FUNCNAME ip_range = $ip_range" 10

    let local whitelist_match=1

    local whitelist
    for whitelist in ${Whitelists[@]}; do
        debug "$FUNCNAME whitelist = $whitelist" 10

        # don't check empty whitelist
        if [ "$whitelist" == "" ]; then
            continue
        fi

        # perfect match
        if [ "$ip" == "$whitelist" ]; then
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist [MATCH, PERFECT]" 22
            let local whitelist_match=0
            break
        fi

        if [[ "$whitelist" == *"/"* ]]; then
            local whitelist_cidr=${whitelist##*/} # ${0##*/}
        else
            local whitelist_cidr=""
        fi

        # make sure whitelist_cidr is an integer
        if [[ ! $whitelist_cidr =~ ^[0-9]+$ ]]; then
            local whitelist_cidr=""
        fi

        if [ "$whitelist_cidr" == "$whitelist" ]; then
            _error "whitelist_cidr == whitelist $whitelist" 3 ERROR # should be dead code, now; leaving to be sure
            continue
        fi

        # if it's not a perfect match, and the whitelist has no host range, then checking other point to point links is pointless
        if [ "$whitelist_cidr" == "" ]; then
            debug "$FUNCNAME ip = $ip, whitelist = $whitelist [SKIP, IMPOSSIBLE]" 4
            continue
        fi

        # the following (depends on subnetcalc) to check host ranges; TODO: write (or find) a better alternative

        debug "$FUNCNAME " 20
        debug "$FUNCNAME ip = $ip, whitelist = $whitelist, whitelist_cidr = $whitelist_cidr" 2
        debug "$FUNCNAME " 20

        debug "$FUNCNAME ip = $ip, whitelist = $whitelist [OK, CHECK]" 22

        # strip the cidr off the ip, replace it with the whitelist mask, & compare ranges
        ip_whitelist=${ip%%/*}
        if [ "$whitelist_cidr" != "" ]; then
            ip_whitelist+="/$whitelist_cidr"
        fi
        local whitelist_range=$(subnetcalc $whitelist -n -nocolor 2> /dev/null | grep ^Host\ Range)
        local ip_whitelist_range=$(subnetcalc $ip_whitelist -n -nocolor 2> /dev/null | grep ^Host\ Range)
        if [ "$whitelist_range" == "" ]; then
            _echo "subnetcalc has an empty host range for ip '$ip' in whitelist '$whitelist'" WARNING
        else
            if [ "$whitelist_range" == "$ip_whitelist_range" ]; then
                let local whitelist_match=0
                debug "$FUNCNAME ip = $ip, whitelist = $whitelist [MATCH, RANGE]" 22
                debug "$FUNCNAME ip = $ip, whitelist = $whitelist ip_whitelist = $ip_whitelist" 14
                debug "$FUNCNAME ip_whitelist_range = $ip_whitelist_range ($ip_whitelist)" 14
            fi
        fi

        debug "$FUNCNAME ip_range           = $ip_range ($ip)" 14
        debug "$FUNCNAME whitelist_range    = $whitelist_range ($whitelist)" 14

        if [ $whitelist_match -eq 0 ]; then
            debug "$FUNCNAME ip = $ip AND whitelist = $whitelist [MATCH]" 5
            _echo "$ip is whitelisted" NOTICE
            return 0
        fi

    done
    unset whitelist

    # debt; new
    # to be ultra safe, ensuring a larger range isn't allowed if a lower range is whitelisted (that's not a point to point)
    # this is especially IMPORTANT when using older versions of ipset that do *not* support nomatch, e.g. ipset v6.11 (RHEL 6)
    # i.e. 10.11.12.224/27 is whitelisted & 10.11.12.0/24 is blacklisted; 10.11.12.0/24 is allowed with only the above logic

    return 1

    # TODO better ipv6 whitelist support
}

# output list of standard locations found for a given filename that's readable
function lablFindLists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local find_lists="$1"
    if [ "$find_lists" == "" ]; then
        debug "$FUNCNAME passed no arguments to $FUNCNAME" 1
        return 1
    fi

    debug "$FUNCNAME find_lists = '$find_lists'" 33

    local labl_etc_d=$(dirname $(dirname $Readlink_0) 2> /dev/null)/etc/labl.d/

    local find_dirs=()
    find_dirs+=(/etc/labl.d)
    find_dirs+=($labl_etc_d)

    local found_lists=()
    for find_dir in ${find_dirs[@]}; do
        debug "$FUNCNAME find_dir = $find_dir" 33
        if [ -r "$find_dir" ]; then
            local candidate
            while read candidate; do
                if [ -r $candidate ]; then
                    debug "$FUNCNAME candidate = $candidate (readable)" 30
                    found_lists+=($candidate)
                else
                    debug "$FUNCNAME candidate = $candidate (not readable)" 30
                fi
            done <<< "$(find "${find_dir}" -maxdepth 1 -type f -name "*${find_lists}*" 2> /dev/null | sort -u)" # only files in this directory; do not recurse
            unset candidate
        fi
    done

    debug "$FUNCNAME found_lists = '$find_lists' = $(echo ${found_lists[@]})" 13

    if [[ "${found_lists[@]}" ]]; then
        echo "${found_lists[@]}"
        return 0
    fi

    return 1
}

# initialize all dependencies, etc.
function lablInit() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$USER" != "root" ]; then
        aborting "must be root" 3
    fi

    # ensure executable dependencies are available
    Dependencies=()
    Dependencies+=(awk)
    Dependencies+=(basename)
    Dependencies+=(cut)
    Dependencies+=(date)
    Dependencies+=(dirname)
    Dependencies+=(find)
    Dependencies+=(ip)
    Dependencies+=(ipset)
    Dependencies+=(printf)
    Dependencies+=(readlink)
    Dependencies+=(subnetcalc) # subnetcalc
    Dependencies+=(sed)
    Dependencies+=(sort)

    local dependency
    for dependency in ${Dependencies[@]}; do
        which $dependency &> /dev/null
        if [ $? -ne 0 ]; then
            aborting "FAILED which dependency '$dependency'" 3
        fi
    done
    unset dependency

    Basename_0=$(basename $0)
    Dirname_0="$(dirname $0)"

    if [ "$Dirname_0" == "." ]; then
        Dirname_0="$PWD"
    fi

    Zero="$Dirname_0/$Basename_0"

    Readlink_0=$(readlink -e $Zero 2> /dev/null)
    if [ "$Readlink_0" == "" ]; then
        aborting "Readlink_0 Zero failed" 3
    fi

    if [ -r "$(dirname ${Readlink_0})/../include/debug-bash/Debug.bash" ]; then
        source "$(dirname ${Readlink_0})/../include/debug-bash/Debug.bash"
    fi

    debug "$FUNCNAME 0 = $0" 5
    debug "$FUNCNAME Debug = $Debug" 1
    debug "$FUNCNAME Basename_0 = $Basename_0" 1
    debug "$FUNCNAME Dirname_0 = $Dirname_0" 5
    debug "$FUNCNAME Readlink_0 = $Readlink_0" 1
    debug "$FUNCNAME Zero = $Zero" 1

    if [ -r "$(dirname ${Readlink_0})/../include/ip-bash/IP.bash" ]; then
        source "$(dirname ${Readlink_0})/../include/ip-bash/IP.bash"
    else
        aborting "IP.bash failed to source"
    fi

    IP_Families=()

    IP6=1 # false
    if [[ "$(ip -6 a s)" != "" ]]; then
        Dependencies+=(ip6tables)
        IP6=0 # true
        IP_Families+=(inet6)
    fi

    IP4=1 # false
    if [[ "$(ip -4 a s)" != "" ]]; then
        Dependencies+=(iptables)
        IP4=0 # true
        IP_Families+=(inet)
    fi

    if [ "$IP_Families" == "" ]; then
        aborting "unable to determine what IP famlies are support on this machine"
    fi

    # re-check dependencies
    local dependency
    for dependency in ${Dependencies[@]}; do
        which $dependency &> /dev/null
        if [ $? -ne 0 ]; then
            aborting "FAILED which dependency '$dependency'" 3
        fi
    done
    unset dependency

    if [ "$Basename_0" == "blacklist" ]; then
        Ipset_Mode="blacklist"
    fi

    if [ "$Basename_0" == "whitelist" ]; then
        Ipset_Mode="whitelist"
    fi

    Status_Flag=0

    # evaluate usage flag as sym link or option (arg 1)
    Flag=$(printf "$Basename_0" | awk -F- '{print $2}')
    if [ "$Flag" == "" ]; then
        Flag="$1"
        let Valid_Flag=1
        if [ "$Flag" != "" ]; then

            for Option in ${Options[@]}; do
                if [ "$Flag" == "$Option" ]; then
                    let Valid_Flag=0
                    break;
                fi
            done

            if usageOptionSingle $Option; then
                if [ "$Ipset_Mode" == "" ]; then
                    Ipset_Mode="$2"
                fi
            else
                IP_Address="$2"
                if [ "$Ipset_Mode" == "" ]; then
                    Ipset_Mode="$3"
                fi
            fi
        else
            IP_Address="$1"
            if [ "$Ipset_Mode" == "" ]; then
                Ipset_Mode="$2"
            fi
        fi

        if [ $Valid_Flag -eq 1 ]; then
            if [ "$Flag" == "" ]; then
                debug "$FUNCNAME no flag" 14
                usage
            else
                Flag=""
                usage "invalid flag"
            fi
        fi

        debug "$FUNCNAME Option = $Option (Flag)" 14
    else
        IP_Address="$1"
        if [ "$Ipset_Mode" == "" ]; then
            Ipset_Mode="$2"
        fi
    fi
    debug "$FUNCNAME Flag = $Flag" 14

    if usageOptionSingle $Option; then
        IP_Address=""
    else
        debug "IP_Address = $IP_Address" 1

        if ! ipValid "$IP_Address"; then
            usage "invalid IP address or CIDR range '$IP_Address'"
        fi

    fi

    # no flag or option, basic usage
    if [ "$Flag" == "" ]; then
        usage
    fi

    if [ "$Ipset_Mode" != "whitelist" ]; then
        Ipset_Mode="blacklist"
    fi
    debug "$FUNCNAME Ipset_Mode = $Ipset_Mode" 5

    Ipset_Version=$(ipset -v 2> /dev/null | awk -F, '{print $1}')
    local -i ipset_version_major=$(echo $Ipset_Version | sed '/[a-z]/s///g' |  awk -F. '{print $1}')
    local -i ipset_version_minor=$(echo $Ipset_Version | sed '/[a-z]/s///g' |  awk -F. '{print $2}')
    # TODO; verify exactly which version of ipset starts supporting nomatch & enhance this to allow versions greater than that
    if [ $ipset_version_major -ge 6 ] && [ $ipset_version_minor -ge 19 ]; then
        let Ipset_Nomatch=0
    else
        let Ipset_Nomatch=1
    fi
    debug "Ipset_Version = $Ipset_Version ($Ipset_Nomatch) [$ipset_version_major][$ipset_version_minor]" 1

    if [ "$Ipset_Name" == "" ]; then
        aborting "Ipset_Name is empty" 3
    fi
    debug "$FUNCNAME Ipset_Name = $Ipset_Name" 14

    Timestamp=$(date +%Y%m%d%H%M%S.%N)
    debug "$FUNCNAME Timestamp = $Timestamp" 14

    Tmp_Dir=$(readlink -e "${Dirname_0}/../tmp")

    if [ "$Tmp_Dir" == "" ]; then
        Tmp_Dir="/var/tmp"
    fi

    if [ ! -d "$Tmp_Dir" ]; then
        mkdir -p "$Tmp_Dir"
        if [ $? -ne 0 ]; then
            aborting "failed to make temp directory '$Tmp_Dir'"
        fi
    fi

    if [ ! -d "$Tmp_Dir" ] || [ ! -w "$Tmp_Dir" ]; then
        aborting "'$Tmp_Dir' temporary directory not writable"
    fi

    Tmp_File=${Tmp_Dir}/${Basename_0}.${Timestamp}
    debug "$FUNCNAME Tmp_File = $Tmp_File" 14
}

# load lists of validated ips from file(s)
function lablLoad() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        debug "$FUNCNAME passed no arguments to $FUNCNAME" 14
        return 1
    fi

    debug "$FUNCNAME arguments = $(echo $@)" 18

    local load_files=()

    local load_candidates=($@)
    for load_candidate in ${load_candidates[@]}; do
        debug "$FUNCNAME load_candidate = ${load_candidate}" 14
        if [ -r $load_candidate ]; then
            debug "$FUNCNAME load_candidate = $load_candidate (readable)" 33
            load_files+=($load_candidate)
        else
            debug "$FUNCNAME load_candidate = $load_candidate (not readable)" 33
        fi
        unset load_candidate
    done
    debug "$FUNCNAME load_files = $(echo ${load_files[@]})" 10

    # pre-load ip(s)

    if [[ "${load_files[@]}" ]]; then

        local load_candidates=()

        local load_file
        for load_file in ${load_files[@]}; do
            if [ -r "${load_file}" ]; then
                local load_script=$(head -1 "${load_file}" 2> /dev/null | grep ^"#!")
                if [ "${load_script}" != "" ]; then
                    debug "$FUNCNAME load_file = $load_file (execute)" 10
                    local load_line
                    while read load_line; do
                        load_candidates+=($load_line)
                    done <<< "$(bash "$load_file" "$Option" | egrep -e '^[0-9]|^[a-f]|^[A-F]' | awk '{print $1}')" # must be one ip per line
                    unset load_line
                else
                    debug "$FUNCNAME load_file = $load_file (cat)" 10
                    local load_line
                    while read load_line; do
                        load_candidates+=($load_line)
                    done <<< "$(cat "$load_file" | egrep -e '^[0-9]|^[a-f]|^[A-F]' | awk '{print $1}')" # must be one ip per line
                    unset load_line
                fi
            fi
        done
        unset load_file

        local load_ips=()

        local load_candidates_uniq=($(printf "%s\n" ${load_candidates[@]} | sort -Vu))
        load_candidates=(${load_candidates_uniq[@]})
        unset load_candidates_uniq

        local load_candidate
        for load_candidate in ${load_candidates[@]}; do
            # skip empty lines
            if [ "${load_candidate}" == "" ]; then
                continue
            fi

            # skip comments
            if [ "${load_candidate:0:1}" == "#" ]; then
                continue
            fi

            debug "$FUNCNAME load_candidate = $load_candidate" 30

            let local valid_load_candidate=1
            if ipValid "$load_candidate"; then
                let local valid_load_candidate=0
            fi

            if [ $valid_load_candidate -eq 0 ]; then
                debug "$FUNCNAME valid load ip = $load_candidate" 7
                load_ips+=($load_candidate)
            else
                if [ $Status_Flag -eq 1 ] ; then
                    _echo "ignoring invalid IP '$load_candidate'" WARNING
                fi
            fi

        done
        unset load_candidate

        if [[ "${load_ips[@]}" ]]; then
            echo "${load_ips[@]}"
            return 0
        fi
    fi

    return 1
}

# load named blacklists into global $Blacklists & $Blacklists_Files
function lablLoadBlacklists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local -l list_labl=blacklist
    else
        list_labl="$1"
    fi
    debug "$FUNCNAME list_labl = $list_labl" 14

    if [[ ${Blacklists[@]} ]]; then
        if [[ ${Blacklists_Files[@]} ]]; then
            debug "$FUNCNAME blacklists already loaded" 10
            return 0
        fi
    fi

    Blacklists_Files=($(lablFindLists $list_labl))
    debug "$FUNCNAME Blacklists_Files = $(echo ${Blacklists_Files[@]})" 10

    Blacklists=()
    if [ "$Blacklists_Files" != "" ]; then
        local blacklist
        for blacklist in $(lablLoad "${Blacklists_Files[@]}"); do
            debug "$FUNCNAME blacklist = $blacklist" 13
            Blacklists+=($blacklist)
        done
        unset blacklist
    fi

    if [[ ${Blacklists[@]} ]]; then
        if [[ ${Blacklists_Files[@]} ]]; then
            local blacklist_from
            for  blacklist_from in ${Blacklists_Files[@]}; do
                if [ $Verbose_Flag -eq 0 ] || [ "$2" == "verbose" ]; then
                    _echo "blacklist loaded from $blacklist_from" OK
                fi
            done
            unset blacklist_from
            return 0
        fi
    fi

    return 1
}

# load named whitelists into global $Whitelists & $Whitelists_Files
function lablLoadWhitelists() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local -l list_labl=whitelist
    else
        list_labl="$1"
    fi
    debug "$FUNCNAME list_labl = $list_labl" 14

    if [[ ${Whitelists[@]} ]]; then
        if [[ ${Whitelists_Files[@]} ]]; then
            debug "$FUNCNAME whitelists already loaded" 10
            return 0
        fi
    fi

    Whitelists_Files=($(lablFindLists $list_labl))
    debug "$FUNCNAME Whitelists_Files = $(echo ${Whitelists_Files[@]})" 10

    Whitelists=()
    if [ "$Whitelists_Files" != "" ]; then
        local whitelist
        for whitelist in $(lablLoad "${Whitelists_Files[@]}"); do
            debug "$FUNCNAME whitelist = $whitelist" 13
            Whitelists+=($whitelist)
        done
        unset whitelist
    fi

    if [[ ${Whitelists[@]} ]]; then
        if [[ ${Whitelists_Files[@]} ]]; then
            local whitelist_from
            for  whitelist_from in ${Whitelists_Files[@]}; do
                if [ $Verbose_Flag -eq 0 ]; then
                    _echo "whitelist loaded from $whitelist_from" OK
                fi
            done
            unset whitelist_from
            return 0
        fi
    fi

    return 1
}

# remove an ip address or range from an ipset
function lablRemove() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ip="$IP_Address"
    else
        local ip="$1"
    fi

    if [ "$ip" == "" ]; then
        debug "$FUNCNAME ip is empty" 14
        return 1
    fi

    if [ "$2" == "blacklist" ]; then
        local blacklist=0
    else
        local blacklist=1
    fi

    if [ "$2" == "whitelist" ]; then
        local whitelist=0
    else
        local whitelist=1
    fi

    if [ "$2" == "" ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local whitelist=0
            local blacklist=1
        else
            local whitelist=1
            local blacklist=0
        fi
    fi

    if [ "$2" == "all" ]; then
        local blacklist=0
        local whitelist=0
    fi

    if [ "$3" == "quiet" ]; then
        local quiet=0
    else
        local quiet=1
    fi

    # ip_families is local here because the given ip may be either a v4 inet addres *or* a v6 inet6 address (or maybe both)
    if ipv4Valid "$ip"; then
        local ip_families=("inet")
    else
        if ipv4ValidCidr "$ip"; then
            local ip_families=("inet")
        else
            if ipv6Valid "$ip"; then
                local ip_families=("inet6")
            else
                if ipv6ValidCidr "$ip"; then
                    local ip_families=("inet6")
                else
                    local ip_families=(${IP_Families[@]})
                fi
            fi
        fi
    fi
    debug "ip_families = ${ip_families[@]}" 7

    for ip_family in ${ip_families[@]}; do

        local blacklist_removed=1
        local whitelist_removed=1
        #local quiet=1

        if [ $blacklist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) blacklist" 14

            if lablCheck "$ip" blacklist quiet; then
                ipset del ${Ipset_Name}_${ip_family} $ip
                if lablCheck "$ip" blacklist quiet; then
                    _echo "$ip is still in blacklist (manually check the CIDR ranges)" WARNING
                else
                    local blacklist_removed=0
                    if [ $quiet -eq 1 ]; then
                        _echo "$ip removed from blacklist" REMOVE
                    fi
                fi
            else
                local blacklist_removed=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT in blacklist" REMOVE
                fi
            fi

            if [ $blacklist -eq 1 ] && [ $whitelist -eq 0 ]; then
                return $blacklist_removed
            fi
        fi

        if [ $whitelist -eq 0 ]; then
            debug "$FUNCNAME ip = $ip ($ip_family) whitelist" 14

            if lablCheck "$ip" whitelist quiet; then
                ipset del ${Ipset_Name}_${ip_family} $ip
                if lablCheck "$ip" whitelist quiet; then
                    _echo "$ip is still in whitelist (manually check the CIDR ranges)" WARNING
                else
                    local whitelist_removed=0
                    if [ $quiet -eq 1 ]; then
                        _echo "$ip removed from whitelist" REMOVE
                    fi
                fi
            else
                local whitelist_removed=0
                if [ $quiet -eq 1 ]; then
                    _echo "$ip is NOT in whitelist" REMOVE
                fi
            fi

            if [ $blacklist -eq 0 ] && [ $whitelist -eq 1 ]; then
                return $blacklist_removed
            fi
        fi

    done

}

# restore ipsets
function lablRestore() {
    debug "$FUNCNAME Function = $FUNCNAME" 50
}

# save ipsets
function lablSave() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    if [ "$1" == "" ]; then
        local ipset_save="${Tmp_File}.save"
    else
        local ipset_save="$1"
    fi

    if [ "$ipset_save" == "" ]; then
        debug "$FUNCNAME ipset_save is empty" 14
        return 1
    fi

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        ipset_family_save="${ipset_save}.${Ipset_Name}_${ip_family}"
        if [ $Auto_Flag -eq 1 ]; then
            _echo "ipset save ${Ipset_Name}_${ip_family} to $ipset_family_save" SAVE
        fi
        ipset save ${Ipset_Name}_${ip_family} | sort -ruV > "$ipset_family_save"
    done
    unset ip_family

}

# check & if needed, create ipsets and iptables/ip6tables rules
function lablStart() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local table_exec

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        unset table_exec

        if [ "$ip_family" == "inet" ]; then
            if [ $IP4 -eq 0 ]; then
                table_exec="iptables"
            fi
        else
            if [ $IP6 -eq 0 ]; then
                table_exec="ip6tables"
            fi
        fi

        if [ "$table_exec" == "" ]; then
            continue
        fi

        debug "$FUNCNAME check $table_exec $ip_family ipset" 10

        # if needed, create ${ip_family} set
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -ne 0 ]; then
            # set doesn't exist, create it
            local ipset_type="hash:net"
            ipset -q create ${Ipset_Name}_${ip_family} $ipset_type hashsize $Ipset_Hashsize maxelem $Ipset_Maxelem family ${ip_family}
            if [ $? -eq 0 ]; then
                _echo "ipset ${Ipset_Name}_${ip_family} created" OK
            else
                aborting "[ERROR] FAILED to ipset create ${Ipset_Name}_${ip_family} $ipset_type hashsize $Ipset_Hashsize maxelem $Ipset_Maxelem family ${ip_family}" 3
            fi
        else
            # set exists, great
            if [ $Verbose_Flag -eq 0 ]; then
                _echo "ipset ${Ipset_Name}_${ip_family} exists" NOTICE
            fi
        fi

        debug "$FUNCNAME check $table_exec $ip_family rule" 10

        # iptables/ip6tables bug ...; sometimes results aren't produced on the first try ... :/
        local table_count=0

        let local table_try=3
        while [ $table_try -gt 0 ]; do
            if [ $table_count -eq 0 ]; then
                local table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            else
                break
            fi
            ((--table_try))
        done
        debug "$FUNCNAME $table_exec $ip_family table_try = $table_try" 10

        if [ $table_count -eq 0 ]; then
            # insert [first rule]
            $table_exec -I INPUT 1 -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP
            if [ $? -eq 0 ]; then
                _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} started" OK
            else
                aborting "[ERROR] FAILED to $table_exec -I INPUT 1 -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP" 3
            fi
        else
            if [ $table_count -eq 1 ]; then
                if [ $Verbose_Flag -eq 0 ]; then
                    _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} running" OK
                fi
            else
                aborting "[ERROR] $table_exec --match-set ${Ipset_Name}_${ip_family} is loaded $table_count times, try restarting" 3
            fi
        fi

    done
    unset ip_family

    if [ $Verbose_Flag -eq 0 ]; then
        printf "\n"
    fi

    if [ $Iptables_Flag -eq 0 ] && [ "$1" == "iptables" ]; then
        _echo "$Basename_0 start successful" "OK"
        return
    fi

    lablLoadBlacklists blacklist
    lablLoadWhitelists whitelist

    if [ $Verbose_Flag -eq 0 ]; then
        printf "\n"
    fi

    if usageOptionSingle $Option; then

        local whitelist
        for whitelist in ${Whitelists[@]}; do
            debug "$FUNCNAME whitelist = $whitelist" 10
            lablAdd $whitelist whitelist
        done
        unset whitelist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        local blacklist
        for blacklist in ${Blacklists[@]}; do
            debug "$FUNCNAME blacklist = $blacklist" 10
            lablAdd $blacklist blacklist
        done
        unset blacklist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        # whitelisting a second time allows whitelists to override blacklists

        local whitelist
        for whitelist in ${Whitelists[@]}; do
            debug "$FUNCNAME whitelist = $whitelist" 10
            lablAdd $whitelist whitelist
        done
        unset whitelist

        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

        _echo "$Basename_0 start successful" "OK"
        if [ $Verbose_Flag -eq 0 ]; then
            printf "\n"
        fi

    fi
}

# list contents of all ipsets & iptables rules
function lablStatus() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    Status_Flag=0

    let local labl_running=1

    local ipset_match=""
    if [ $Ipset_Nomatch -eq 0 ]; then
        if [ "$Ipset_Mode" == "whitelist" ]; then
            local ipset_match="nomatch"
        fi
    fi

    local labl_inet_count=0
    local labl_inet_blacklist_count=0
    local labl_inet_whitelist_count=0

    local labl_inet6_count=0
    local labl_inet6_blacklist_count=0
    local labl_inet6_whitelist_count=0

    local ip_family_count=0

    local table_exec

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        unset table_exec

        if [ "$ip_family" == "inet" ]; then
            if [ $IP4 -eq 0 ]; then
                table_exec="iptables"
            fi
        else
            if [ $IP6 -eq 0 ]; then
                table_exec="ip6tables"
            fi
        fi

        if [ "$table_exec" == "" ]; then
            continue
        fi

        debug "$FUNCNAME check $table_exec $ip_family ipset" 10

        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -eq 0 ]; then
            let local labl_running=0

            if [ $ip_family_count -eq 0 ]; then
                echo "----------------------------------------------------------------"
                echo
                let ip_family_count=$ip_family_count+1
            fi

            ipset -t list ${Ipset_Name}_${ip_family} 2> /dev/null > /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
            if [ -r /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp} ]; then
                cat /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
            fi

            debug "$FUNCNAME check $table_exec $ip_family rule" 10

            # iptables/ip6tables bug ...; sometimes they doesn't produce results on the first try ...
            local table_count=0

            let local table_try=3
            while [ $table_try -gt 0 ]; do
                if [ $table_count -eq 0 ]; then
                    table_count=$($table_exec -n -L INPUT | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
                else
                    break
                fi
                ((--table_try))
            done

            debug "$FUNCNAME table_try = $table_try" 10

            echo

            if [ $table_count -eq 0 ]; then
                echo "[-] $table_exec --match-set ${Ipset_Name}_${ip_family} is NOT loaded"
            else
                if [ $table_count -eq 1 ]; then
                    echo "[+] $table_exec --match-set ${Ipset_Name}_${ip_family} is loaded"
                    echo
                else
                    echo "[WARNING] $table_exec --match-set ${Ipset_Name}_${ip_family} is loaded $table_count times"
                    echo
                fi

                if [ "$1" != "permanent" ] || [ "$1" != "verbose" ]; then
                    continue
                fi

                lablLoadBlacklists blacklist
                lablLoadWhitelists whitelist

                #
                # blacklist status
                #

                let local labl_blacklist_count=$(ipset save ${Ipset_Name}_${ip_family} | grep ^add | grep -v nomatch$ | wc -l)
                if [ $labl_blacklist_count -eq 0 ]; then
                    let local labl_blacklists_count=1
                else
                    let local labl_blacklists_count=0
                fi

                if [[ ${Blacklists_Files[@]} ]]; then
                    echo "[+]"
                    echo "[+] Blacklists ($ip_family)"
                    echo "[+]"
                    echo
                    local blacklists_file
                    for blacklists_file in ${Blacklists_Files[@]}; do
                        let blacklists_file_count=0
                        echo "$blacklists_file"
                        echo
                        Status_Flag=1
                        if [ "$ip_family" == "inet6" ]; then
                            local blacklist_inet
                            for blacklist_inet in $(printf "%s\n" $(lablLoad $blacklists_file) | egrep -e '^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*'); do
                                echo $blacklist_inet
                                let blacklists_file_count=$blacklists_file_count+1
                                if [ $labl_blacklists_count -eq 1 ]; then
                                    let labl_blacklist_count=$labl_blacklist_count+1
                                fi
                            done
                            unset blacklist_inet
                        else
                            local blacklist_inet
                            for blacklist_inet in $(printf "%s\n" $(lablLoad $blacklists_file) | egrep -e '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'); do
                                echo $blacklist_inet
                                let blacklists_file_count=$blacklists_file_count+1
                                if [ $labl_blacklists_count -eq 1 ]; then
                                    let labl_blacklist_count=$labl_blacklist_count+1
                                fi
                            done
                            unset blacklist_inet
                        fi
                        if [ $blacklists_file_count -eq 0 ]; then
                            echo "!! empty $ip_family blacklist !!"
                        fi
                        Status_Flag=0
                        echo
                    done
                    unset blacklists_file
                    echo
                fi

                if [ "${ip_family}" == "inet" ]; then
                    let labl_inet_count=$labl_inet_count+$labl_blacklist_count
                    let labl_inet_blacklist_count=$labl_inet_blacklist_count+$labl_blacklist_count
                fi

                if [ "${ip_family}" == "inet6" ]; then
                    let labl_inet6_count=$labl_inet6_count+$labl_blacklist_count
                    let labl_inet6_blacklist_count=$labl_inet6_blacklist_count+$labl_blacklist_count
                fi

                #
                # whitelist status
                #

                let local labl_whitelist_count=$(ipset save ${Ipset_Name}_${ip_family} | grep ^add | grep nomatch$ | wc -l)
                if [ $labl_whitelist_count -eq 0 ]; then
                    let local labl_whitelists_count=1
                else
                    let local labl_whitelists_count=0
                fi

                if [[ ${Whitelists_Files[@]} ]]; then
                    echo "[+]"
                    echo "[+] Whitelists ($ip_family)"
                    echo "[+]"
                    echo
                    local whitelists_file
                    for whitelists_file in ${Whitelists_Files[@]}; do
                        let whitelists_file_count=0
                        echo "$whitelists_file"
                        echo
                        Status_Flag=1
                        if [ "$ip_family" == "inet6" ]; then
                            local whitelist_inet
                            for whitelist_inet in $(printf "%s\n" $(lablLoad $whitelists_file) | egrep -e '^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*'); do
                                echo $whitelist_inet
                                let whitelists_file_count=$whitelists_file_count+1
                                if [ $labl_whitelists_count -eq 1 ]; then
                                    let labl_whitelist_count=$labl_whitelist_count+1
                                fi
                            done
                            unset whitelist_inet
                        else
                            local whitelist_inet
                            for whitelist_inet in $(printf "%s\n" $(lablLoad $whitelists_file) | egrep -e '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'); do
                                echo $whitelist_inet
                                let whitelists_file_count=$whitelists_file_count+1
                                if [ $labl_whitelists_count -eq 1 ]; then
                                    let labl_whitelist_count=$labl_whitelist_count+1
                                fi
                            done
                            unset whitelist_inet
                        fi
                        if [ $whitelists_file_count -eq 0 ]; then
                            echo "!! empty $ip_family whitelist !!"
                        fi
                        Status_Flag=0
                        echo
                    done
                    unset whitelists_file
                    echo
                fi

                if [ "${ip_family}" == "inet" ]; then
                    let labl_inet_count=$labl_inet_count+$labl_whitelist_count
                    let labl_inet_whitelist_count=$labl_inet_whitelist_count+$labl_whitelist_count
                fi

                if [ "${ip_family}" == "inet6" ]; then
                    let labl_inet6_count=$labl_inet6_count+$labl_whitelist_count
                    let labl_inet6_whitelist_count=$labl_inet6_whitelist_count+$labl_whitelist_count
                fi

                # ip_family summary

                echo "[+]"
                echo "[+] Summary ($ip_family)"
                echo "[+]"
                echo
                echo "$labl_blacklist_count blacklisted & $labl_whitelist_count whitelisted ${ip_family} addresses and/or ranges"
                echo
            fi
            echo
        fi

        if [ $labl_running -eq 0 ]; then
            echo "----------------------------------------------------------------"
            echo
        fi
    done
    unset ip_family

    if [ $Iptables_Flag -ne 0 ]; then
        if [ $labl_running -eq 0 ]; then
            if [ $labl_inet_count -eq 0 ] && [ $labl_inet6_count -eq 0 ]; then
                echo "labl is running"
                echo
            else
                echo "$labl_inet6_blacklist_count blacklisted and $labl_inet6_whitelist_count whitelisted v6 IP addresses"
                echo "$labl_inet_blacklist_count blacklisted and $labl_inet_whitelist_count whitelisted v4 IP addresses"
                echo
                echo "labl is running, $labl_inet_count v4 and $labl_inet6_count v6 addresses loaded"
                echo

                # TODO debt; this part works but needs work.
                if [ $Permanent_Flag -eq 0 ]; then

                    echo "[+]"
                    echo "[+] Permanent (check); $Blacklist_Permanent_File"
                    echo "[+]"
                    echo

                    if [ ! -d $(dirname "$Blacklist_Permanent_File") ]; then
                        mkdir -p "$(dirname "$Blacklist_Permanent_File")" &> /dev/null
                        if [ $? -ne 0 ]; then
                            aborting "[ERROR] mkdir -p $(dirname "$Blacklist_Permanent_File") failed"
                        fi
                    fi

                    echo

                    local permanent_qualifiers=0

                    local ip_family
                    for ip_family in ${IP_Families[@]}; do
                        while read blacklist_ip; do
                            if ipv4Valid $blacklist_ip; then
                                local blacklist_qualifier=$(echo "$blacklist_ip" | awk -F\. '{print $1"."$2"."$3}')
                                local blacklist_qualifier_count=$(ipset save ${Ipset_Name}_${ip_family} | grep -v nomatch$ | awk '{print $NF}' | grep ^${blacklist_qualifier}\. | wc -l)
                                if [ $blacklist_qualifier_count -gt $Blacklist_Permanent_Max ]; then
                                    if ! grep ^${blacklist_qualifier}.0/24 "$Blacklist_Permanent_File" &> /dev/null; then
                                        _echo "# blacklisted ip = $blacklist_ip, qualifier $blacklist_qualifier currently has $blacklist_qualifier_count blacklisted which is >= $Blacklist_Permanent_Max" WARNING
                                        echo "${blacklist_qualifier}.0/24" >> "${Blacklist_Permanent_File}"
                                        if [ $? -eq 0 ]; then
                                            _echo "# ${blacklist_qualifier}.0/24 added to $Blacklist_Permanent_File" NOTICE
                                        else
                                            _error "# ${blacklist_qualifier}.0/24 failed to add to $Blacklist_Permanent_File" ERROR
                                        fi
                                        let permanent_qualifiers=$permanent_qualifiers+1
                                    fi
                                fi
                            fi
                        done <<<  "$(ipset save ${Ipset_Name}_${ip_family} | grep -v nomatch$ | grep ^add | awk '{print $NF}' | grep -v \/ | sort -uV)"
                    done
                    unset ip_family

                    if [ ${permanent_qualifiers} -le 0 ]; then
                        _echo "permanent check completed; no qualifiers found" OK
                    else
                        if [ -w "${Blacklist_Permanent_File}" ]; then
                            sort -uV "${Blacklist_Permanent_File}" -o "${Blacklist_Permanent_File}"
                        fi
                    fi

                fi

            fi
        else
            echo
            echo "labl is NOT running"
            echo
        fi
    fi

    ${table_exec} -L INPUT -n

    # clean up
    local ip_family
    for ip_family in ${IP_Families[@]}; do
        if [ -r /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp} ]; then
            rm -f /var/tmp/${Ipset_Name}_${ip_family}.status.${Timestamp}
        fi
    done
    unset ip_family

    exit 0
}

# remove all ip family rules & ipsets
function lablStop() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local rc=0

    local table_exec

    local ip_family
    for ip_family in ${IP_Families[@]}; do
        unset table_exec

        if [ "$ip_family" == "inet" ]; then
            if [ "$IP4" -eq 0 ]; then
                table_exec="iptables"
            fi
        else
            if [ "$IP6" -eq 0 ]; then
                table_exec="ip6tables"
            fi
        fi

        if [ "$table_exec" == "" ]; then
            continue
        fi

        debug "$FUNCNAME check $table_exec $ip_family rule" 10

        # iptables/ip6tables bug ???; sometimes they don't produce results on the first try ... ???

        local table_count=0
        let local table_exec_rc=0
        let local table_stopped=0
        let local table_try=0
        let local table_try_max=10

        for ((table_try=0; table_try<$table_try_max; table_try++)); do
            local table_count=$($table_exec -n -L INPUT 2> /dev/null | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            if [ $table_count -ne 0 ]; then
                break
            fi
        done
        debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try" 3

        if [ $table_count -gt 0 ]; then
            # match-set.labl_ is loaded into iptables

            for ((table_try=0; table_try<$table_try_max; table_try++)); do
                $table_exec -D INPUT -m set --match-set ${Ipset_Name}_${ip_family} src -j DROP &> /dev/null
                table_exec_rc=$?
                if [ $table_exec_rc -eq 0 ]; then
                    let table_stopped=$table_stopped+1
                    break
                fi
                debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try, table_exec_rc=$table_exec_rc" 4
            done
            debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try, table_try_max = $table_try_max" 4

        else
            debug "$FUNCNAME $table_exec --match-set ${Ipset_Name}_${ip_family} stopped" 10
        fi

        # second time, check to be sure it's stopped
        for ((table_try=0; table_try<$table_try_max; table_try++)); do
            local table_count=$($table_exec -n -L INPUT 2> /dev/null | grep ^DROP.*match-set.labl_${ip_family}.src | wc -l)
            if [ $table_count -ne 0 ]; then
                break
            fi
        done
        debug "$FUNCNAME $table_exec $ip_family table_count = $table_count, table_try = $table_try" 3


        if [ $table_count -gt 0 ]; then
            _error "FAILED to remove $table_exec --match-set ${Ipset_Name}_${ip_family}" ERROR
            rc=4
        else
            if [ $table_stopped -gt 0 ]; then
                _echo "$table_exec --match-set ${Ipset_Name}_${ip_family} stopped" OK
            else
                _echo "[-] $table_exec --match-set ${Ipset_Name}_${ip_family} NOT loaded" NOTICE
            fi
        fi

        # check ${ip_family} set
        ipset -q -t list ${Ipset_Name}_${ip_family} &> /dev/null
        if [ $? -eq 0 ]; then
            ipset -q destroy ${Ipset_Name}_${ip_family}
            if [ $? -eq 0 ]; then
                _echo "destoyed ipset ${Ipset_Name}_${ip_family}" OK
            else
                _error "FAILED to destoy ipset ${Ipset_Name}_${ip_family}" ERROR
                rc=4
            fi
        else
            _echo "ipset ${Ipset_Name}_${ip_family} NOT loaded" NOTICE
        fi

    done
    unset ip_family

    if [ -f "${Tmp_File}" ]; then
        rm -f "${Tmp_File}" &> /dev/null
    fi

    if [ $rc -ne 0 ]; then
        _error "FAILED to $Basename_0 $Option" ERROR
        exit $rc
    else
        if usageOptionSingle $Option; then
            _echo "$Basename_0 stop successful" "OK"
        fi
    fi

}

# cli usage
function usage() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local ip_address="<ip|ip/cidr>"

    local usage_header="usage: $Basename_0"
    local usage_footer=" [blacklist|whitelist] # optional, blacklist is default"
    if [ "$Flag" == "" ]; then
        local usage_message="$usage_header <"
        for Option in ${Options[@]}; do
            # these options do NOT require an ip|ip/cdr
            if usageOptionSingle $Option; then
                continue
            fi
            usage_message+="$Option|"
        done
        unset Option
        usage_message=$(printf "$usage_message" | sed -e '/|$/s///g')
        usage_message+="> $ip_address"
        if [ "$Ipset_Mode" == "" ]; then
            local usage_message+=$usage_footer
        fi
        usage_message+="\n-or-\n$usage_header <auto|iptables|restart|start|status|stop>"
    else
        if [ "$Option" == "$Flag" ]; then
            local usage_message="$usage_header $Option $ip_address"
        else
            local usage_message="$usage_header $ip_address"
        fi
        if [ "$Ipset_Mode" == "" ]; then
            local usage_message+=$usage_footer
        fi
    fi
    if [ "$1" != "" ]; then
        usage_message+="\n\nNOTE: $@"
    fi
    printf "\n$usage_message\n\n"

    exit 1
}

# cli usage options that don't require any extra arguments
function usageOptionSingle() {
    debug "$FUNCNAME Function = $FUNCNAME" 50

    local option="$1"

    if [ "$option" == "auto" ] || [ "$option" == "restart" ] || [ "$option" == "save" ] || [ "$option" == "start" ] || [ "$option" == "iptables" ] || [ "$option" == "status" ] || [ "$option" == "stop" ]; then
        return 0
    fi

    return 1
}

# Main

lablInit $@

# supported options without other arguments are restart, start, status, stop

# iptables is a special option, exit
Iptables_Flag=1 # 0=true, 1=false
if [ "$Option" == "iptables" ]; then
    Start_Flag=0 # 0=true, 1=false
    Status_Flag=0 # 0=true, 1=false
    Iptables_Flag=0 # 0=true, 1=false
    lablStart iptables
    lablStatus iptables
    exit
fi

# status is a special option, exit
Permanent_Flag=1 # 0=true, 1=false
Status_Flag=1 # 0=true, 1=false
if [ "$Option" == "status" ]; then
    Status_Flag=0
    if [ "$2" == "permanent" ]; then
        Permanent_Flag=0 # 0=true, 1=false
        lablStatus
    else
        lablStatus "$2"
    fi
    exit
fi

# start is a special option, exit
Start_Flag=1 # 0=true, 1=false
if [ "$Option" == "start" ]; then
    Start_Flag=0 # 0=true, 1=false
    lablStart
    exit
fi

# stop is a special option, exit
Stop_Flag=1 # 0=true, 1=false
if [ "$Option" == "stop" ]; then
    Stop_Flag=0 # 0=true, 1=false
    lablStop
    exit
fi

# restart is a special option, exit
Restart_Flag=1 # 0=true, 1=false
if [ "$Option" == "restart" ]; then
    Restart_Flag=0 # 0=true, 1=false
    lablStop
    lablStart
    exit
fi

Save_Flag=1 # 0=true, 1=false
if [ "$Option" == "save" ]; then
    Save_Flag=0 # 0=true, 1=false
    lablSave "$IP_Address"
    exit
fi

Remove_Flag=1 # 0=true, 1=false
# auto is super special, it requires lablStart but no IP validation
Auto_Flag=1 # 0=true, 1=false
if [ "$Option" == "auto" ]; then
    Auto_Flag=0 # 0=true, 1=false
    lablAuto
else
    # all other supported options require a valid(ated) IP Address, ipset(s), and iptables/ip6tables rules
    lablStart
fi

Add_Flag=1 # 0=true, 1=false
if [ "$Option" == "add" ]; then
    Add_Flag=0 # 0=true, 1=false
    lablAdd "$IP_Address" "$Ipset_Mode"
    exit
fi

Check_Flag=1 # 0=true, 1=false
if [ "$Option" == "check" ]; then
    Check_Flag=0 # 0=true, 1=false
    lablCheck "$IP_Address"
    exit
fi

if [ "$Option" == "remove" ]; then
    Remove_Flag=0 # 0=true, 1=false
    lablRemove "$IP_Address"
    exit
fi

#
# Copyright (C) 2018, Joseph Tingiris
#
